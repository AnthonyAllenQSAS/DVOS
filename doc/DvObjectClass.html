<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
    <meta content="text/html; charset=windows-1252" http-equiv="Content-Type">
    <title>DvObject Class</title>
  </head>
  <body>
    <div style="text-align: center; font-family:
      Helvetica,Arial,sans-serif;">
      <div style="text-align: center;">
        <div style="text-align: center;">
<div align="left">
  <h1 align="center">DVOS Data Object Library<br>
  </h1>
  <h3>Contents</h3>
  <ul>
<li>

  <a href="#Scheme">Data Variable Object Scheme</a></li><li><a href="#Pointers">Dvar 'Pointers'</a></li><li><a href="#DvObject">DvObject Class</a></li><li><a href="#Join">DvJoinList Class</a></li><li><a href="#Mask">DvMask Class</a></li><li><a href="#Node">DvNode and DvList Classes</a></li><li><a href="#XML">XML Methods</a></li><li><a href="#String">DvString Class</a></li><li><a href="#Time">DvTime Class</a></li><li><a href="#Event">DvEvent Class</a></li><li><a href="#MatEig">DvMatrixEig Class</a></li><li><a href="#MinVar">DvMinVariance Class</a></li><li><a href="#Util">Accessible Internal Utilities</a>

    </li>
  </ul>
</div>
<big style="font-weight: bold;"><br>
  <br>
  <a name="Scheme"></a>Data








            Variable Object Scheme</big><br>
        </div>
        <br>
        <div style="text-align: left;"> The purpose of the new data
          handling core (DVOS) is to remove performance bottlenecks inm
          QDOS. At the same time it should simplify coding within QSAS
          and plugins, and make the whole package easier to maintain
          when it moves wholely into public domain maintenance. <br>
          <br>
          Specifically, in contrast to QDOS, data objects are a single
          class and <span style="font-weight: bold;">not</span> a
          hierarchy of classes handling different data types and
          dimensionality. Objects are still accessed through var
          pointers, which allows for data to be self-destroying when out
          of scope, but it is no longer necessary to narrow objects to
          specific sub-classes (scalar, matrix, scalar sequence, matrix
          sequence <span style="font-style: italic;">etc</span>).<br>
          <br>
          The single class handles all necessary data conversions and
          dimensions transparently, which in turn means less coding in
          the calling modules, and hence easier maintenance. The
          reduction in layers of abstraction also make it easier for the
          community to understand and maintain the core code itself. As
          many operations as possible are handled by the DVOS core, and
          this includes intelligent handling of fill values and
          metadata. All operations supported are safe against the
          underlying data types and invalid operations will do nothing
          (rather than throw an exception), so calling a supported
          method is always safe. The only exception to this are a few
          explicit de-reference methods used for fast access directly
          into the data valarrays. They are to be used only for looping
          explicitly through the data when dimensionality and data type
          has been checked. Safe (but slower) options for each of these
          are also supported.<br>
          <br>
          The data itself is held in a valarray, and the object knows
          how to unpack the records and matrix dimensions appropriately.
          This ensures that copying data and constructing objects that
          are sequences of arrays is very much faster than in QDOS where
          matrix sequences were sequences of var pointers to matrices.
          Most methods and operators are handled at the top level by the
          object so as to minimise the number of operations that require
          stepping through the valarray data itself. Where possible
          valarray supported methods are used to avoid explicit valarray
          element access, and for this the fill values are set to NaN
          for double data to ensure they remain unaltered by arithmetic
          operations.<br>
          <br>
          <br>
        </div>
        <div style="text-align: center;"><big><br>
          </big></div>
        <big style="font-weight: bold;"><a name="Pointers"></a>Dvar 'Pointers'</big><br>
      </div>
      <br>
      <div style="text-align: left;"> The Dvar template class provides a
        wrapper for data objects that ensures they are deleted when they
        go out of scope. They are not strictly pointers, but are a class
        containing a pointer to the data object and a dereference
        operator (-&gt;) defined such that they may be used like
        pointers to the data object.<br>
        <br>
        Every time a var pointer is created, the reference counter for
        the target object is incremented, and whenever a Dvar object is
        deleted (or goes out of scope) the reference counter is
        decremented. When the counter is zero the data object is
        deleted.<br>
        <br>
        Explicitly the QSAS data variable object class, DvObject, may be
        accessed via the Dvar pointer class for it, DvObject_var. From
        here on we shall discuss the DvObject_var derived class. The
        class contains a pointer to a DvObject class data object which
        is <span style="font-weight: bold;">nesver null</span>. <br>
        <br>
        There are three constructors:<br>
        <br>
        <span style="font-weight: bold;">DvObject_var ()</span>
        constructs an 'empty' DvObject (see the DvObject class) and
        returns is_nil() as true.<br>
        <br>
        <span style="font-weight: bold;">DvObject_var</span> (const
        DvObject_var &amp;T) constructs an object that points to the
        same object that T points to. The object is not copied or
        changed other than to increment its reference pointer.<br>
        <br>
        <span style="font-weight: bold;">DvObject_var</span> ( DvObject
        *P) constructs an object that points to the object P. The object
        is not copied or changed other than to increment its reference
        pointer.<br>
        <br>
        There is an assignment <span style="font-weight: bold;">operator








          =</span>, that takes a DvObject pointer as argument, and this
        is used to assign a Dvar pointer to an object created with the <span style="font-weight: bold;">new </span>command. Additionally
        there is a similar assignment <span style="font-weight: bold;">operator








          =</span>, that takes a <span style="font-weight: bold;">DvObject_var</span>
        reference as argument.<br>
        <br>
        For example, where (...) refers to any argument list taken by
        DvObject constructors:<br>
        <br>
        <span style="font-family: Courier New,Courier,monospace;">DvObject_var








          dobj; </span>// creates a pointer to an 'empty' data object
        (is_nil() returns true)<br>
        <span style="font-family: Courier New,Courier,monospace;">dobj =
          new DvObject(...); </span>// <span style="font-weight:
          bold;">creates a new data object</span> and points dobj to it
        (deleting orphaned object automatically, e.g. 'empty' object
        above)<br>
        <span style="font-family: Courier New,Courier,monospace;">DvObject_var








          dobj2 = dobj; </span>// creates a new Dvar pointer to the
        object in dobj<br>
        <span style="font-family: Courier New,Courier,monospace;">DvObject_var








          dobj3(dobj);</span> // also creates a new Dvar pointer to the
        object in dobj <br>
        <span style="font-family: Courier New,Courier,monospace;">dobj3
          += dobj;</span> // <span style="font-weight: bold;">adds</span>
        the content of dobj to that of dobj3 (and ensures units are the
        same, converting a copy of dobj on the fly as needed)<br>
        <br>
        Note that a new object is usually created using the assignment
        operator (through the explicit 'new') and these take <span style="font-weight: bold;">any</span> of the constructors for
        the <span style="font-weight: bold;">DvObject</span> class as
        the RHS.<br>
        <br>
        The <span style="font-weight: bold;">ptr()</span> method gives
        direct access to the pointer to the <span style="font-family:
          Courier New,Courier,monospace;"><span style="font-weight:
            bold;"></span> </span><span style="font-weight: bold;">DvObject








        </span>data object inside Dvar.&nbsp; <br>
        <br>
        The de-reference <span style="font-weight: bold;">operator
          -&gt;,</span>&nbsp; gives direct access to the methods
        available in the DvObject data class, while the operator, *,
        gives access to the data object itself. Hence <span style="font-weight: bold;">dobj-&gt;seqSize()</span> and <span style="font-weight: bold;">(*dobj).seqSize()</span> both
        return the length of the data sequence provided by the DvObject
        method seqSize().<br>
        <br>
        The comparison <span style="font-weight: bold;">operators</span>
        <span style="font-weight: bold;">== and != </span>compare the
        data <span style="font-weight: bold;">object_id</span> values.
        Each non-empty object has a unique id, which can be found from <span style="font-weight: bold;">dobj-&gt;get_id()</span>, and these
        comparisons determine whether the Dvar pointers refer to exactly
        the same target data object. To compare data values other
        operators are provided in the DvObject data class, for example <span style="font-family: Courier New,Courier,monospace;">*dobj1 ==
          *dobj2</span> compares the data arrays in each object.<br>
        'Empty' objects all have id = -1, and are therefore always equal
        to each other.<br>
        <br>
        The bool methods<span style="font-weight: bold;">&nbsp; is_nil()
        </span>and&nbsp;<span style="font-weight: bold;"> is_ok() </span>return









        the equivalent methods from the data class, so <span style="font-family: Courier New,Courier,monospace;">dobj-&gt;is_nil()</span>
        and <span style="font-family: Courier New,Courier,monospace;">dobj.is_nil()</span>
        are equivalent. If there is data in the target data object, then
        is_nil() is false and is_ok() is true, and vice versa. The
        pointer to the enclosed data object is never actually nil, and
        all methods can be called safely. Data object methods that are
        not applicable to the underlying data type <span style="font-weight: bold;">do nothing</span> but attach an
        error message to any returned object.<br>
        <br>
        Note, however, that the data arrays inside the DvObject are
        valarrays, and these do not do array bound checking. Under most
        circumstances the DvObjects can perform whatever operations are
        required through defined methods and operators, and only when
        accessing data element by element will it be necessary to
        determine the data type and valarray length. See the <span style="font-weight: bold;">DvObject class</span>.<br>
        <br>
        A DvObject_var may be used as a return value from a method. It
        may also be passed in an argument by value or reference. <br>
        <br>
        If passed by value a new DvObject_var is created which points to
        the same object target. Changes to this object affect the object
        in the calling function, but if the DvObject_var is changed to
        point to a new target, that change will <span style="font-weight: bold;">not</span> propagate back to the
        calling function. <br>
        <br>
        Passing by reference is slightly faster and the same pointer and
        target are involved, and <span style="font-weight: bold;">all</span>
        changes affect the calling function.<br>
        <br>
        Most operators supported by <span style="font-family: Courier
          New,Courier,monospace;"><span style="font-weight: bold;"></span>
        </span><span style="font-weight: bold;">DvObject </span>are
        also available directly from<span style="font-weight: bold;"> </span><span style="font-family: Courier New,Courier,monospace;"><span style="font-weight: bold;"></span> </span><span style="font-weight: bold;">DvObject_var</span> for
        convenience. Operators normally result in a new object being
        created and assigned to the target <span style="font-weight:
          bold;"></span><span style="font-family: Courier
          New,Courier,monospace;"><span style="font-weight: bold;"></span>
        </span><span style="font-weight: bold;">DvObject_var</span>, the
        exception being operators of the form +=, -=, /=, *= which
        modify the target object directly and are thus slightly faster
        than the equivalent binary operators, +, -, /, * which create a
        new object.<br>
        <br>
      </div>
      <br>
      <big><br>
        <span style="font-weight: bold;"><a name="DvObject"></a>DvObject Class</span></big><br>
    </div>
    <br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">The DvObject
      class provides a single class for data objects that contains the
      data in a valarray of appropriate type and all metadata (xrefs) as
      a vector of DvNode objects. Every object of class DvObject has a
      unique id which may be accessed via <span style="font-weight:
        bold;"><br>
        get_id()</span>. If two var pointers refer to the same data
      object then obj1-&gt;get_id() == obj2-&gt;get_id() will be true.</span><br>
    <br style="font-family: Helvetica,Arial,sans-serif;">
    <br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"> DvObject
      objects are normally handled via the DvObject_var wrapper class
      that ensures data is deleted when it goes out of scope. It is
      possible to use DvObjects directly for local temporary storage
      where objects are going to be destroyed explicitly [if created
      using 'new', DvObject *d= new DvObject(...) ] or by going out of
      scope if created directly as an instance, DvObject(...). </span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"> <br>
      Consequently, methods that return a pointer to a new DvObject
      (DvObject *) must be used <span style="font-weight: bold;">only</span>
      with a var pointer, e.g.</span><br>
    <span style="font-family: Courier New,Courier,monospace;">DvObject_var








      obj = this-&gt;subset(0, 10);</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;">and not</span><br>
    <span style="font-family: Courier New,Courier,monospace;">DvObject
      *ptr = this-&gt;subset(0, 10);</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"> even though
      subset returns DvObject *.<br>
      <br>
      The DvObject may contain data of </span><span style="font-weight:
      bold; font-family: Helvetica,Arial,sans-serif;">one</span><span style="font-family: Helvetica,Arial,sans-serif;"> of the following
      types:</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">double</span><br style="font-weight:
      bold; font-family: Helvetica,Arial,sans-serif;">
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">int</span><br style="font-weight:
      bold; font-family: Helvetica,Arial,sans-serif;">
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">DvString</span><br style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">DvTime</span><br style="font-weight:
      bold; font-family: Helvetica,Arial,sans-serif;">
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">DvEvent</span><span style="font-family: Helvetica,Arial,sans-serif;"> (a time interval
      type)</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"> and a
      valarray is resized to hold the data when allocated through the </span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">operator =</span><span style="font-family: Helvetica,Arial,sans-serif;"> or one of the
      constructors.</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"> The methods
      <br>
    </span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">is_dbl(), <br>
      is_int(), <br>
      is_str(), <br>
      is_time() </span><span style="font-family:
      Helvetica,Arial,sans-serif;">and</span><span style="font-weight:
      bold; font-family: Helvetica,Arial,sans-serif;"> <br>
      is_event()</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> may be used to determine the type
      data contained. It is only necessary to determine the data type
      when accessing elements directly as all methods (unless otherwise
      stated) are safe to use with all data types, and will do nothing
      if not appropriate to the data type held. DVOS itself will never
      throw an exception.</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">The
      equivalent negated methods are also available, <br>
      <span style="font-weight: bold;">not_dbl()</span> etc.</span><br>
    <br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">
      Additionally, the methods </span><span style="font-weight: bold;
      font-family: Helvetica,Arial,sans-serif;"><br>
      is_ok()</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> and <br>
    </span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">is_nil() </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
      can be used to determine if any data is available, or if the
      object is 'empty'. Note that operations on empty objects (except
      direct access of data elements in the valarrays) are always safe
      as methods operate only on non-empty valarrays (and similarly
      lists of xrefs). An object that <span style="font-weight: bold;">is_nil()</span>
      will also have id = -1. </span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"> The data are
      treated as though a sequence of arrays of any rank (number of
      dimensions). There are short-cut access routines up to rank 4, but
      higher dimension data may be accessed by performing array index
      arithmetic explicitly. If the array dimension vector is empty then
      the data is treated as a sequence of single values, and if the
      sequence length is one the data is taken to be a single array (or
      single value if the dimension vector is zero). Each record in the
      sequence must have the <span style="font-weight: bold;">same </span>rank.</span>
    <span style="font-family: Helvetica,Arial,sans-serif;">Within the
      valarrays the last dimension varies the fastes and record number
      varies the slowest so that the data is packed as a sequence of C
      arrays.</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Array
      Dimensions and Sequence sizes<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;">The
      methods:</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">size_t seqSize()</span><span style="font-family: Helvetica,Arial,sans-serif;"> returns the
      length of the sequence</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">vector &lt;size_t&gt; &amp; Dims()</span><span style="font-family: Helvetica,Arial,sans-serif;"> returns the
      dimensions of the arrays (the same for all records in the
      sequence)</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">size_t nDims()</span><span style="font-family: Helvetica,Arial,sans-serif;"> is a shortcut to
      Dims().size() and gives the number of dimensions (rank)</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">size_t arraySize()</span><span style="font-family: Helvetica,Arial,sans-serif;"> is the total
      number of elements in each array</span> = <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">Dims[0] </span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">* </span><span style="font-weight:
      bold; font-family: Helvetica,Arial,sans-serif;">Dims[1]</span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;"> * ... * </span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">Dims[</span><span style="font-weight:
      bold; font-family: Helvetica,Arial,sans-serif;"> nDims()</span><span style="font-family: Helvetica,Arial,sans-serif;"> -</span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;"> 1 ]</span> <br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">size_t totalSize()</span><span style="font-family: Helvetica,Arial,sans-serif;"> the total size
      of the valarray</span> = <span style="font-weight: bold;
      font-family: Helvetica,Arial,sans-serif;">seqSize() * </span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">arraySize()</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Destuctor<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;">The
      destructor should never be called. Objects should always be
      pointed to using DvObject_var pointers,<br>
      in which case the object will self destruct when no longer in
      scope anywhere. It is dangerous to explicitly delete a DvObject<br>
      as it may be in use elsewhere.<br style="font-family:
        Helvetica,Arial,sans-serif;">
    </span> <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);"><br>
      Constuctors<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;">There
      are general constructors and specific constructors for each data
      type (also see <span style="font-weight: bold;">subSequence()</span>
      operators below which may act as copy constructors):</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"> Empty
      constructor:</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">DvObject ()</span><span style="font-family: Helvetica,Arial,sans-serif;"> constructs a
      DvObject with a single double (0.0). This is the object created
      for an 'empty' DvObject_var() constructor. It has object_id=-1 and
      so returns is_nil() as true, but is otherwise safe. It returns
      seqSize() as 0, but totalSize()</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> and arraySize() will be 1. These
      objects are not intended to be used other than safe place holders.
      Use</span><span style="font-family: Helvetica,Arial,sans-serif;"></span>
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">DvObject (0.0) </span><span style="font-family: Helvetica,Arial,sans-serif;">to construct a
      valid single double with value zero.</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;">Copy
      Constructors</span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;"><br>
      DvObject(DvObject_var obj, bool withXrefs=true) </span><span style="font-family: Helvetica,Arial,sans-serif;">constructs a copy
      of the object pointed to by obj</span><span style="font-weight:
      bold; font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">, including xrefs</span><span style="font-family: Helvetica,Arial,sans-serif;"> if withXrefs is
      true (default)</span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;"><br>
      DvObject(DvObject &amp;obj</span><span style="font-weight: bold;
      font-family: Helvetica,Arial,sans-serif;">, bool withXrefs=true</span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">) </span><span style="font-family:
      Helvetica,Arial,sans-serif;">constructs a copy of the object obj</span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;">, </span><span style="font-family:
      Helvetica,Arial,sans-serif;">including xrefs</span><span style="font-family: Helvetica,Arial,sans-serif;"> if withXrefs is
      true (default)</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">DvObject(DvObject *ob</span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">j, bool withXrefs=true</span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> </span><span style="font-weight:
      bold; font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">constructs a copy
      of the object obj</span><span style="font-weight: bold;
      font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">,</span><span style="font-family: Helvetica,Arial,sans-serif;"> including xrefs</span><span style="font-family: Helvetica,Arial,sans-serif;"> if withXrefs is
      true (default)</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">DvObject(DvObject_var &amp;obj,
      size_t nRecs</span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-weight:
      bold; font-family: Helvetica,Arial,sans-serif;">, bool
      withXrefs=true</span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">)<br>
    </span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">DvObject(DvObject *obj, size_t nRecs</span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-weight:
      bold; font-family: Helvetica,Arial,sans-serif;">, bool
      withXrefs=true</span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> both </span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;">construct a copy of the first record
      in <span style="font-weight: bold;">obj</span> repeated <span style="font-weight: bold;">nRecs</span> times</span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;">, </span><span style="font-family:
      Helvetica,Arial,sans-serif;">includes xrefs</span><span style="font-family: Helvetica,Arial,sans-serif;"> if withXrefs is
      true (default)</span><span style="font-family:
      Helvetica,Arial,sans-serif;">. It is provided for internal use to
      repeat single values across a sequence, e.g.</span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;"></span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Courier New,Courier,monospace;">DvObject_var
      d0 = getDep0(); // get Depend_0<br>
    </span><span style="font-family: Courier New,Courier,monospace;">
      DvObject_var tags = new DvObject(d0.ptr(), (size_t) 1); // create
      new object of the first record<br>
    </span><span style="font-family: Courier New,Courier,monospace;"><span style="font-family: Helvetica,Arial,sans-serif;">or more simply</span><br>
      DvObject_var d0 = getDep0()-&gt;subSequence(0); // get Depend_0
      first record<br>
    </span><span style="font-family: Courier New,Courier,monospace;"><br>
    </span><span style="font-family: Courier New,Courier,monospace;"> </span><span style="font-family: Courier New,Courier,monospace;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;">Data
      typ</span><span style="font-family: Helvetica,Arial,sans-serif;">e
      specific </span><span style="font-family:
      Helvetica,Arial,sans-serif;">constructors:<br>
      <span style="font-style: italic;">Sequence, of nRecs, set to
        value, default is single value</span><br>
      &nbsp; <span style="font-weight: bold;">DvObject(double value</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, size_t nRecs=1</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; DvObject(int value</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRecs=1</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; DvObject(DvString value</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRecs=1</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; DvObject(DvTime value</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRecs=1</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; DvObject(DvEvent value</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRecs=1</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">);<br>
        &nbsp;<br>
      </span><span style="font-style: italic;">Sequence of single values
        with length of valarray size</span><span style="font-weight:
        bold;"><br>
        &nbsp; DvObject(valarray &lt;double&gt; &amp;from);<br>
        &nbsp; DvObject(valarray &lt;int&gt; &amp;from);<br>
        &nbsp; DvObject(valarray &lt;DvString&gt; &amp;from);<br>
        &nbsp; DvObject(valarray &lt;DvTime&gt; &amp;from);<br>
        &nbsp; DvObject(valarray &lt;DvEvent&gt; &amp;from);<br>
        <br>
      </span><span style="font-style: italic;">Sequence, nRecs, </span></span><span style="font-family: Helvetica,Arial,sans-serif; font-style:
      italic;">of dimensions dims,&nbsp;</span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-style: italic;">
        all initialised with value</span><span style="font-weight:
        bold;"> <br>
        &nbsp; DvObject(double value, vector &lt;size_t&gt; &amp;dims, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRecs=1);<br>
        &nbsp; DvObject(int value, vector &lt;size_t&gt; &amp;dims, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRecs=1);<br>
        &nbsp; DvObject(DvString value, vector &lt;size_t&gt; &amp;dims,
      </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRecs=1);<br>
        &nbsp; DvObject(DvTime value, vector &lt;size_t&gt; &amp;dims, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRecs=1);<br>
        &nbsp; DvObject(DvEvent value, vector &lt;size_t&gt; &amp;dims,
      </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRecs=1);<br>
        <br>
      </span><span style="font-style: italic;">Construct from valarrays
        of data, length of valarrays must match (or exceed) product of
        array dimensions and sequence length</span><span style="font-weight: bold;"><br>
        &nbsp; DvObject(valarray &lt;double&gt; &amp;from, vector
        &lt;size_t&gt; &amp;dims, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRecs=1);<br>
        &nbsp; DvObject(valarray &lt;int&gt; &amp;from, vector
        &lt;size_t&gt; &amp;dims, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRecs=1);<br>
        &nbsp; DvObject(valarray &lt;DvString&gt; &amp;from, vector
        &lt;size_t&gt; &amp;dims, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRecs=1);<br>
        &nbsp; DvObject(valarray &lt;DvTime&gt; &amp;from, vector
        &lt;size_t&gt; &amp;dims, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">siDvMaskze_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRecs=1);<br>
        &nbsp; DvObject(valarray &lt;DvEvent&gt; &amp;from, vector
        &lt;size_t&gt; &amp;dims, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRecs=1);</span></span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> </span><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-style: italic;">Assignment








        </span><br>
        &nbsp; void assign_regular(double h)</span> leaves the first
      value in the valarray unchanged and adds h incrementally to each
      subsequent entry. It has no effect if the data type is not a <span style="font-weight: bold;">double</span> or <span style="font-weight: bold;">DvTime</span>. This is convenient for
      creating regular Depend_0 variables, e.g.</span><br>
    <span style="font-family: Courier New,Courier,monospace;">DvObject_var








      d0 = getDep0(); // get existing Depend_0</span><span style="font-family: Courier New,Courier,monospace;"><br>
    </span><span style="font-family: Courier New,Courier,monospace;">DvObject_var








      tags = new DvObject(d0.ptr(), n); // create new object with first
      record of this repeated n times</span><br style="font-family:
      Courier New,Courier,monospace;">
    <span style="font-family: Courier New,Courier,monospace;">tags-&gt;assign_regular(hReg);








      // replace data with regular spaced data off the first value</span>
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
      Note that this works exactly the same for a scalar or time
      sequence for Depend_0.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
      The assignment operator:</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif;">operator =</span><span style="font-family: Helvetica,Arial,sans-serif;">,&nbsp; takes a
      DvObject as argument, and assigns the contents of the object to
      that of the argument (including xrefs). Note this differs from the
      assignment operator for DvObject_var. For example:<br>
    </span><span style="font-family: Courier New,Courier,monospace;">DvObject_var








      dobj1 = new </span><span style="font-family: Courier
      New,Courier,monospace;">DvObject</span><span style="font-family:
      Courier New,Courier,monospace;">(3.0); </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Courier New,Courier,monospace;">DvObject_var








      dobj2</span><span style="font-family: Courier
      New,Courier,monospace;"> = new </span><span style="font-family:
      Courier New,Courier,monospace;">DvObject</span><span style="font-family: Courier New,Courier,monospace;">(7.0)</span><span style="font-family: Courier New,Courier,monospace;">; </span><br>
    <span style="font-family: Courier New,Courier,monospace;">dobj1 = </span><span style="font-family: Courier New,Courier,monospace;">dobj2;&nbsp;
      // points dobj1 to the contents of dobj2 and increments the
      reference counter of *dobj2<br>
    </span><span style="font-family: Courier New,Courier,monospace;">cout








      &lt;&lt; *dobj1 &lt;&lt; endl; // = 7.0, the data object holding
      3.0 deleted itself<br>
    </span><span style="font-family: Courier New,Courier,monospace;">cout








      &lt;&lt; (dobj1-&gt;get_id() == </span><span style="font-family:
      Courier New,Courier,monospace;">dobj2-&gt;get_id()</span><span style="font-family: Courier New,Courier,monospace;">) &lt;&lt;
      endl; // true, both vars point to same object<br>
    </span><span style="font-family: Courier New,Courier,monospace;">*dobj1








      = *dobj2;&nbsp; // assigns the data and xrefs in dobj1 to be the
      same as in dobj2 (neither reference counter changes)<br>
      cout &lt;&lt; dobj1-&gt;dbl() &lt;&lt;</span><span style="font-family: Courier New,Courier,monospace;"> endl; // =
      7.0, see below</span><span style="font-family: Courier
      New,Courier,monospace;"><br>
    </span><span style="font-family: Courier New,Courier,monospace;">cout








      &lt;&lt; (dobj1-&gt;get_id() == </span><span style="font-family:
      Courier New,Courier,monospace;">dobj2-&gt;get_id()</span><span style="font-family: Courier New,Courier,monospace;">) &lt;&lt;
      endl; // false, two different objects holding the same data values
      (copy)<br>
    </span><br style="font-family: Helvetica,Arial,sans-serif;">
    <br>
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Fast Access</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">Fast data
      access routines are provided for stepping through the data arrays
      (valarrays). These <span style="font-weight: bold;">DO NOT</span>
      do array bound or data type checking which is left to the calling
      function (see examples).<br>
      <span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double &amp;dbl(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> k, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> m)</span> returns the reference to
      the double held in a 4D array at the specified element [i,j,k,m]
      for record nRec.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
        double &amp;dbl(</span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> k)</span> returns the reference to
      the double held in a 3D array at the specified element [i,j,k] for
      record nRec.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double &amp;dbl(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j)</span> returns the reference to
      the double held in a 2D array at the specified element [i,j] for
      record nRec.</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double &amp;dbl(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i)</span> returns the reference to
      the double held in a 1D array at the specified element [i] for
      record nRec.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double &amp;dbl(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> posn)</span> returns the reference
      to element at position posn in the valarray. It is used for
      explicit navigation of the data array, for example when the array
      rank is greater than 4 or the matrix dimension is irrelevant
      (stepping through all elements). If no argument is given the first
      data point is returned, and this is used for access of single
      scalar values.<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double &amp;dbl(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, vector &lt;size_t&gt;
        &amp;index)</span> returns the reference to the element at
      record <span style="font-weight: bold;">nRec</span> and array
      position given by the vector <span style="font-weight: bold;">index</span>.
      The size of <span style="font-weight: bold;">index</span> must
      match the data array <span style="font-weight: bold;">nDims</span>().<br>
      <br>
      Note that a single array of rank greater than 1 it is necessary to
      specify that record zero is used, e.g. obj-&gt;dbl(0, i, j), since
      otherwise the i will be used as record number, obj-&gt;dbl(i,j) is
      record i and element j of the array stored in c order (last index
      varies fastest).<br>
      However, the special case of a single rank 1 array it will be safe
      to just step along the dimension since obj-&gt;dbl(i) and
      obj-&gt;dbl(0,i) will return the same element.<br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;">
      Identical methods are available for all supported data types:<br>
      <span style="font-weight: bold;">int &amp;itg(...)</span> </span><span style="font-family: Helvetica,Arial,sans-serif;">returns the
      reference to the integer at the appropriate valarray element,
      where <span style="font-weight: bold;">(...)</span> are the same
      as for <span style="font-weight: bold;">dbl(...)</span> above.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString &amp;str(...)</span> </span><span style="font-family: Helvetica,Arial,sans-serif;">returns the
      reference to the DvString at the appropriate valarray element,
      where <span style="font-weight: bold;">(...)</span> are the same
      as for <span style="font-weight: bold;">dbl(...)</span> above.<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime &amp;time(...)</span> </span><span style="font-family: Helvetica,Arial,sans-serif;">returns the
      reference to the DvTime at the appropriate valarray element, where
      <span style="font-weight: bold;">(...)</span> are the same as for
      <span style="font-weight: bold;">dbl(...)</span> above.<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvEvent &amp;event(...)</span> </span><span style="font-family: Helvetica,Arial,sans-serif;">returns the
      reference to the DvEvent at the appropriate valarray element,
      where <span style="font-weight: bold;">(...)</span> are the same
      as for <span style="font-weight: bold;">dbl(...)</span> above.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;">Thus<br>
    </span><span style="font-family: Courier New,Courier,monospace;">valarray








      &lt;double&gt; dd(6);<br>
      vector &lt;size_t&gt; size;<br>
      size.push_back(3);<br>
      size.push_back(2); // Note last index varies fastest<br>
      dd[0] = 11;<br>
      dd[1] = 12;<br>
      dd[2] = 21;<br>
      dd[3] = 22;<br>
      dd[4] = 31;<br>
      dd[5] = 32;<br>
      dobj = new DvObject(dd, size);</span> // create 1 record holding
    3x2 array of doubles<br>
    <span style="font-family: Courier New,Courier,monospace;">for(int
      i=0; i&lt;size[0]; i++){<br>
      &nbsp;&nbsp; </span><span style="font-family: Courier
      New,Courier,monospace;">for(int j=0; j&lt;size[1]; j++){<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; dobj-&gt;dbl(0, i, j)
      &lt;&lt; "&nbsp; "; // nRec = 0 for single record<br>
      &nbsp;&nbsp; }<br>
      &nbsp;&nbsp; cout &lt;&lt; endl;<br>
      };</span><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
    <span style="font-family: Helvetica,Arial,sans-serif;">output is</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"> 11&nbsp; 12</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"> 21&nbsp; 22</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"> 31&nbsp; 32</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"> </span><br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">valarray &lt;double&gt; record(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> r)&nbsp;</span> returns a valarray
      of doubles to give fast access to the double data elements in the
      data array at the specified record. If the object does not hold
      double data or the requested record is out of range a valarray
      containing a single array of zeros is returned. Thus</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Courier New,Courier,monospace;">nrec








      = 0;<br>
      valarray &lt;double&gt; val = dobj[nrec];</span> // fetch 1 record
    of doubles<br>
    <span style="font-family: Courier New,Courier,monospace;">for(int
      i=0; i&lt;val.size(); i++)</span><span style="font-family: Courier
      New,Courier,monospace;">cout &lt;&lt; val[i] &lt;&lt; ", "; <br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;">output
      is</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"> 11,&nbsp; 12</span><span style="font-family: Helvetica,Arial,sans-serif;">,&nbsp; 21,&nbsp;
      22,</span><span style="font-family: Helvetica,Arial,sans-serif;">&nbsp;







      31,&nbsp; 32, which is the inverse of the above example. </span><br>
    <br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">valarray &lt;double&gt;&amp;
        d_valarray()&nbsp;</span> gives direct access to the valarray of
      doubles for the special case of double data. This circumvents the
      data arrays being protected, and should be used with caution and
      only when speed is important. Intended for internal use, but
      described for completeness.</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><br>
    <br>
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Safe Fast
      Access</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">A safe
      version of fast data access routines are also provided. These are
      naturally slower as they do type and array bound checking. For
      example </span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double








        &amp;dblS(double safe, </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> k, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> m)</span> is the same as </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double &amp;dbl(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> k, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> m)</span></span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;">except that
      if the data type is not double or the request is out of array
      bounds a static local double is returned containing the value <span style="font-weight: bold;">safe</span>.<br>
      The access methods are...<br>
      <span style="font-weight: bold;">&nbsp; double &amp; dblS(double
        safe, </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> k, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> m);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; double &amp; dblS(double
        safe, </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> k);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; double &amp; dblS(double
        safe, </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; double &amp; dblS(double
        safe, </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; double &amp; dblS(double
        safe, </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> posn=0);&nbsp;</span> element at
      this location in valarray, single scalar can use dblS()<br style="font-weight: bold;">
      <br style="font-weight: bold;">
      <span style="font-weight: bold;">&nbsp; int &amp; itgS(int safe, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> k, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> m);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; int &amp; itgS(int safe, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> k);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; int &amp; itgS(int safe, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; int &amp; itgS(int safe, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; int &amp; itgS(int safe, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> posn=0);&nbsp;</span> element at
      this location in valarray, single scalar can use itgS()<br style="font-weight: bold;">
      <br style="font-weight: bold;">
      <span style="font-weight: bold;">&nbsp; DvString &amp;
        strS(DvString safe, </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> k, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> m);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; DvString &amp;
        strS(DvString safe, </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> k);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; DvString &amp;
        strS(DvString safe, </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; DvString &amp;
        strS(DvString safe, </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; DvString &amp;
        strS(DvString safe=</span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString()</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> posn=0);&nbsp;</span> element at
      this location in valarray, single string can use strS()<br style="font-weight: bold;">
      <br style="font-weight: bold;">
      <span style="font-weight: bold;">&nbsp; DvTime &amp; timeS(DvTime
      </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">safe</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> k, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> m);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; DvTime &amp; timeS(DvTime
      </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">safe</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> k);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; DvTime &amp; timeS(DvTime
      </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">safe</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; DvTime &amp; timeS(DvTime
      </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">safe</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; DvTime &amp; timeS(DvTime
      </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">safe=</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime()</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> posn=0);&nbsp;</span> element at
      this location in valarray, single time can use timeS()<br style="font-weight: bold;">
      <br style="font-weight: bold;">
      <span style="font-weight: bold;">&nbsp; DvEvent &amp;
        eventS(DvEvent </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">safe</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> k, int m);</span><br style="font-weight: bold;">
      <span style="font-weight: bold;">&nbsp; DvEvent &amp;
        eventS(DvEvent </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">safe</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> k);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; DvEvent &amp;
        eventS(DvEvent </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">safe</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> j);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; DvEvent &amp;
        eventS(DvEvent </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">safe</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> nRec, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> i);</span><br style="font-weight:
        bold;">
      <span style="font-weight: bold;">&nbsp; DvEvent &amp;
        eventS(DvEvent </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">safe=</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvEvent()</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> posn=0);&nbsp;</span> element at
      this location in valarray, single event can use eventS()<br style="font-weight: bold;">
      <br>
    </span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Subsetting
      Sequences</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">Methods are
      provided that extract data by record.<br>
      <span style="font-weight: bold;">DvObject_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">subSequence</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">(size_t nRec)</span> returns a new
      object containing the single record at <span style="font-weight:
        bold;">nRec</span>, with all xrefs (subset if needed) <br>
      <span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var


          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>subSequence(size_t


        fromRec, size_t</span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
        toRec</span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span></span><span style="font-family: Helvetica,Arial,sans-serif;"> returns a new
      object containing the record between <span style="font-weight:
        bold;">fromRec</span> and <span style="font-weight: bold;">toRec</span>
      inclusive, with all xrefs (subset if needed)</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span> </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
        DvObject</span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>subSequence(DvEvent
        &amp;range</span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span></span><span style="font-family: Helvetica,Arial,sans-serif;"> returns a new
      object containing the records for which timetags are within <span style="font-weight: bold;">range</span>.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var


          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>subSequence(slice


        sl</span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, size_t len=0)</span></span><span style="font-family: Helvetica,Arial,sans-serif;"> returns a new
      object containing the data valarray sliced using <span style="font-weight: bold;">sl</span>, with all xrefs (subset if
      needed)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span>
    </span><br>
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);"><span style="color: rgb(51, 0, 51);">void apply_mask(DvMask &amp;msk)</span></span><span style="font-family: Helvetica,Arial,sans-serif; color: rgb(153, 0,
      0);"><span style="color: rgb(51, 0, 51);"> applies the mask to the
        object and its xrefs, and resizes it accordingly. The xrefs are
        coppied before the mask is applied to them. Records with msk
        true are kept.</span></span><span style="font-weight: bold;
      font-family: Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);"><br>
    </span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);"><br>
      Create Similar Objects</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">Methods are
      provided that create an object of the same type, but with new
      dimensions or sequence length.<br>
      <span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject *create(vector
        &lt;size_t&gt; dims, int nRec)</span> returns a new object of
      the same data type but with nRec records in the sequence and array
      dimensions dims. All elements are filled with the default object
      of this type.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject *create( int nRec)</span>
      returns a new object of the same data type and array dimensions,
      but with nRec records in the sequence. </span><span style="font-family: Helvetica,Arial,sans-serif;">All elements are
      filled with the default object of this type.</span><br>
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);"> </span><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif;
      color: rgb(153, 0, 0);"></span><span style="font-weight: bold;
      font-family: Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);"><br>
    </span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Replacing Data
      in Objects</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">These methods
      delete the existing data (of any type) within an object and
      replace it with the valarray <span style="font-weight: bold;">data</span>
      and with the same type as the valarray.<br>
      <span style="font-weight: bold;">void replaceData(valarray
        &lt;double&gt; &amp;data)<br>
      </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void
        replaceData(valarray &lt;int&gt; &amp;data)</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
        void replaceData(valarray &lt;DvString&gt; &amp;data)</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
        void replaceData(valarray &lt;DvTime&gt; &amp;data)</span></span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void replaceData(valarray
        &lt;DvEvent&gt; &amp;data)</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
      Dimensions and sequence length are left unchanged, so they must be
      explicitly corrected if changed, e.g. using<br>
      <span style="font-family: Courier New,Courier,monospace;">obj-&gt;seqLen








        = records;<br>
        obj-&gt;dims.clear();<br>
        obj-&gt;dims.push_back(len);<br>
        <br>
      </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> <br>
      </span></span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Intervals</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">Methods are
      provided specifically for locating time or scalar Depend_0
      bounding records. If the search fails, <span style="font-weight:
        bold;">recL</span> and <span style="font-weight: bold;">recU</span>
      return -1.<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void getBounds(int &amp;recL, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">int</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> &amp;recU, DvTime &amp;t)</span>
      locates the records that bound the specified time <span style="font-weight: bold;">t</span> in a monotonic time&nbsp;
      sequence)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void getBounds(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">int </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">&amp;recL, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">int</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> &amp;recU, double d)</span> locates
      the records that bound the specified value <span style="font-weight: bold;">d</span> in a monotonic scalar
      sequence)<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void getRecBounds(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">int</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> &amp;recL, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">int</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> &amp;recU, double start, double end)</span>
      locates the records that bound the specified scalar interval
      between <span style="font-weight: bold;">start</span> and <span style="font-weight: bold;">end</span> in a monotonic scalar
      sequence)</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void getEventRecBounds(size_t
        &amp;recL, size_t &amp;recU, DvEvent &amp;range)</span> locates
      the records that bound the specified time interval <span style="font-weight: bold;">range</span> in a monotonic
      time&nbsp; sequence)</span><br>
    <br>
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);"> <br>
      Record Operators</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">An ope</span><span style="font-family: Helvetica,Arial,sans-serif;">rator that allows
      access to the elements of the data array at a record, [r], works
      through an intermediary class, <span style="font-weight: bold;">DvRecord</span>.
      This class has a set of operators defined on it that apply
      directly to the specified record. It is rarely necessary to use
      the <span style="font-weight: bold;">DvRecord class</span> itself
      as it is provided purely as a convenience class to allow records
      to be used as both l and r values. For example<br>
      <span style="font-family: Courier New,Courier,monospace;">&nbsp;seq[2]








        = DvNaN; // DvNaN holds the local value for NaN</span><br style="font-family: Courier New,Courier,monospace;">
      <span style="font-family: Courier New,Courier,monospace;">&nbsp;seq[0]








        = seq[2];</span><br>
      will set all the elements of record 2 to NaN, and then copy these
      values into record 0. Note that the DvRecord class always gives
      access to the actual record in the <span style="font-weight:
        bold;">DvObject</span>. To take a copy of the data array it
      should be copied to a valarray. Note also that the <span style="font-weight: bold;">record(int r)</span> method (above)
      is a specific shortcut to get a copy of the double data valarray
      at the specified record in objects containing double data. <br>
      Example, to interpolate data records of arbitrary dimensions onto
      a DEPEND_0, target:<br>
      &nbsp;<span style="font-family: Courier New,Courier,monospace;"> </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Courier New,Courier,monospace;">// create n
        records containing first record of this</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Courier New,Courier,monospace;"><br>
        DvObject_var result = new DvObject(this, n); <br>
        ...<br>
        &nbsp;// interpolate <br>
        &nbsp;double factor = (target[i] - ssThis[i_this]) /
        (ssThis[i_this] - ssThis[i_this-1]);<br>
        &nbsp;result[i] = (*this)[i_this];</span><br style="font-family:
        Courier New,Courier,monospace;">
      <span style="font-family: Courier New,Courier,monospace;">&nbsp;result[i]








        -= (*this)[i_this-1] ;</span><br style="font-family: Courier
        New,Courier,monospace;">
      <span style="font-family: Courier New,Courier,monospace;">&nbsp;result[i]








        *= factor;</span><br style="font-family: Courier
        New,Courier,monospace;">
      <span style="font-family: Courier New,Courier,monospace;">&nbsp;result[i]








        += (*this)[i_this-1];</span><br style="font-family: Courier
        New,Courier,monospace;">
      <br>
      Operations between records are thus handled as well as operations
      between records and single values. The above sample works for
      objects containing double, int and DvTime data types (int types
      will truncate at each step, so should be treated with caution).
      The DvTime type is safe, but the intermediate values of += and -=
      are not valid date_times, and resolution can be lost when /= and
      *= are used with values far from unity.<br>
      <br>
      Operators supported are <span style="font-weight: bold;">=, +=,
        -=, *=, /=</span> with arguments of double, int, DvTime,
      DvString and DvEvent and valarrays and DvRecord containers of the
      same. Not all arguments are valid for all data types. </span><span style="font-family: Helvetica,Arial,sans-serif;">When the
      operation is meaningless, the result is unchanged. Note however,
      that sensible conversions between DvString and DvTime are made
      where possible.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
      Note that if the requested record is off the end of the data
      sequence, then the first record is always returned. This has the
      effect that a sequence of a single element (or array) will behave
      like a sequence of any length with the first element repeated.
      This can be convenient if it is not known in advance whether a
      variable is record varying or not (e.g. DELTA_PLUS or DEPEND_1).<br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void setRecord(size_t nRec, size_t
        oRec, DvObject* obj) </span>sets record <span style="font-weight: bold;">[nRec] </span>of this object to that
      of record <span style="font-weight: bold;">[oRec]</span> of
      object <span style="font-weight: bold;">obj</span>.<br>
      &nbsp;No bounds checking is done, but convenient for merging or
      shuffling records between objects.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Conversions</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">The "toType"
      conversions return a valarray holding the same data, but converted
      to the appropriate data type. They may be used inside a
      constructor if the converted data is to be kept, but are normally
      expected to be for local use (hence the valarray rather than a
      DvObject). An optional default value may be provided, and if not
      set, the standard default for the type is used - zero for double
      and int, and empty string or MJD 2000 for time.<br>
      If the conversion is not possible the valarray contains all
      default values.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
      <span style="font-weight: bold;">valarray &lt;double&gt;
        toDouble(double safeDefault) </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
      <span style="font-weight: bold;">valarray &lt;int&gt; toInt(int
        safeDefault) </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
      <span style="font-weight: bold;">valarray &lt;DvString&gt; toStr(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">safeDefault</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">) </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
      <span style="font-weight: bold;">valarray &lt;DvTime&gt; toTime(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">safeDefault</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">) </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span><br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;">The
      "asType" conversions will retrieve a single specified element from
      the data array converted to the required data type.<br>
      If the conversion is not possible the safe default is returned.</span><span style="font-family: Helvetica,Arial,sans-serif;"> This form is not
      efficient with large data arrays, but convenient for small data
      objects such as attributes or single values.<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double&nbsp;&nbsp;&nbsp;&nbsp;
        asDouble(size_t posn=0, double safeDefault=0) </span></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double&nbsp;&nbsp;&nbsp;&nbsp;
        asDouble(size_t posn, </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t








        i, </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double








        safeDefault=0) </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double&nbsp;&nbsp;&nbsp;&nbsp;
        asDouble(size_t posn, </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double safeDefault=0) </span></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double&nbsp;&nbsp;&nbsp;&nbsp;
        asDouble(size_t posn, </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t k, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double safeDefault=0) </span></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double&nbsp;&nbsp;&nbsp;&nbsp;
        asDouble(size_t posn, </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t i, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t j, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t k, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t m, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double safeDefault=0) </span></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;








        asInt(size_t posn=0, int safeDefault=0) </span></span><span style="font-family: Helvetica,Arial,sans-serif;">etc<br>
      <span style="font-weight: bold;">DvString&nbsp;&nbsp; asStr(size_t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> posn=0, DvString </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">safeDefault=DvString()</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">) </span></span><span style="font-family: Helvetica,Arial,sans-serif;">etc<br>
      <span style="font-weight: bold;">DvTime&nbsp;&nbsp;&nbsp;&nbsp;
        asTime(size_t</span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
        posn=0, DvTime </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">safeDefault=DvTime()</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">) </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span>etc</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
      It is thus possible to work with data in a specific data type.<br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var


          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>&nbsp;


        convertToDbl()</span> is a convenience for handling data of an
      unknown type by converting to a double object, for example where
      an operation may not be possible for an integer type, or where
      rescaling could cause truncation. It returns a new object with the
      data as doubles.<span style="font-weight: bold;">
        &nbsp;&nbsp;&nbsp; </span></span><br>
    <br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString&nbsp; getTypeAsText() </span>returns









      a text string specifying the data type stored. Possible values are
      "CHAR", "DOUBLE", "INT", "ISO_TIME", "ISO_TIME_RANGE".&nbsp;<span style="font-weight: bold;">&nbsp;&nbsp; </span></span><br>
    <br>
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Operators</span><br style="font-family: Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">Explicit</span><big style="font-family: Helvetica,Arial,sans-serif;"><small> operators
        are supported when appropriate to the underlying data
        type.&nbsp; Operators create a new object containing the result
        (or an empty object if the operation is not meaningful for the
        data types) and hence return a <span style="font-weight: bold;">DvObject








          *</span>. The exceptions are operators of the form +=, *=, etc
        which modify the target object, and hence return </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">DvObject &amp;</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>. Unit
        handling (and conversion on the fly if necessary and possible)
        using SI_conversion and vector frame checking is automatic.
        Joining using linear interpolation is also automatic if
        necessary. Xrefs are modified and attached to the result where
        possible. The data type and dimension is always taken from first
        argument. e.g.<br>
      </small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small> </small></big><span style="font-family: Courier New,Courier,monospace;">valarray
      &lt;double&gt; x(2);<br>
      x[0] = 0.0;<br>
    </span><span style="font-family: Courier New,Courier,monospace;">x[1]








      = 1.0;</span><span style="font-family: Courier
      New,Courier,monospace;"><br>
      DvObject_var y = new DvObject(2.0);</span><span style="font-family: Courier New,Courier,monospace;"><br>
    </span><big style="font-family: Helvetica,Arial,sans-serif;"><small>
      </small></big><span style="font-family: Courier
      New,Courier,monospace;">DvObject_var z = x + y;</span> // holds
    the double values (2.0, 3.0)<br>
    <span style="font-family: Courier New,Courier,monospace;"><br>
      Note also that <br>
    </span><span style="font-family: Courier New,Courier,monospace;">DvObject_var








      x = new DvObject(100.);</span><big style="font-family:
      Helvetica,Arial,sans-serif;"><small> </small></big><span style="font-family: Courier New,Courier,monospace;"><br>
      DvObject_var y = new DvObject(" 10.^2 is");</span><span style="font-family: Courier New,Courier,monospace;"><br>
    </span><span style="font-family: Courier New,Courier,monospace;"> </span><big style="font-family: Helvetica,Arial,sans-serif;"><small> </small></big><span style="font-family: Courier New,Courier,monospace;">DvObject_var s
      = y + x;</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">// holds the DvString value "&nbsp;
      10.^2&nbsp; is </span><span style="font-family: Courier
      New,Courier,monospace;"><span style="font-family:
        Helvetica,Arial,sans-serif;">100."</span><br>
      DvObject_var z = x + y;</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">// holds the double value 200. as the
      DvString.toDouble() understands latex as well as C syntax numbers</span><br>
    <br>
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Modifying
      Operators (single value args)</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">These all
      return DvObject&amp; as they change the object itself (<span style="font-weight: bold;">this</span>). Each of these
      operations are applied to each element in the object
      independently.<br>
      These operators are of the type<span style="font-weight: bold;">
        DvObject obj operator+=(double, int, DvString etc)</span> where
      the RHS is a single value are not accessible directly from the var
      pointer, which must be dereferened to use them (e.g. <span style="font-family: Courier New,Courier,monospace;">DvObject_var
        obj; *obj += i;</span>) This differs from operators of the type
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject obj
        operator+=(DvObject&amp;) </span>which can be used via the var
      pointer </span><span style="font-family:
      Helvetica,Arial,sans-serif;">(e.g.&nbsp;<span style="font-family:
        Courier New,Courier,monospace;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Courier New,Courier,monospace;">DvObject_var
        obj;</span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-family: Courier
        New,Courier,monospace;"> DvObject_var obj2;</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Courier New,Courier,monospace;"> obj +=
        obj2;</span>) </span><span style="font-family:
      Helvetica,Arial,sans-serif;">.<br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;">They
      are valid respectively for the specified data types below:</span><br>
    <br>
    <big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">operator+=</span>&nbsp; double+=all
        (event adds duration, </small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small>DvTime += DvTime gives a
        non-valid time, but is useful as an intermediate step in a chain
        of operations</small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small>), int+=all, </small></big><span style="font-family: Helvetica,Arial,sans-serif;">DvTime</span><big style="font-family: Helvetica,Arial,sans-serif;"><small>+=double
        (the time is incremented by double, default is seconds).</small></big><span style="font-family: Helvetica,Arial,sans-serif;"><br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;">Note
      additionally that</span><br>
    <big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">operator+=</span>&nbsp; DvEvent and
        DvString are also provided and have the special meaning of
        appending either an event or string to a sequence of events or
        strings. This is a convenience for adding events to event tables
        or strings to lists of strings. Has no action if the base object
        is not of the same data type as the argument.<br>
        Note, however, that DvObject</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>::operator+=(DvString)








        will append a string to the sequence of strings, while </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>DvString::operator+=(DvString)








        will append to the DvString</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>.</small></big>
    <br>
    <big style="font-family: Helvetica,Arial,sans-serif;"><small> <br>
      </small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><span style="font-weight:
          bold;">operator-=</span>&nbsp; double-=(double,int),&nbsp;
        int-=(int,double), </small></big><span style="font-family:
      Helvetica,Arial,sans-serif;">DvTime</span><big style="font-family:
      Helvetica,Arial,sans-serif;"><small>-=(double, DvTime)&nbsp; (the
        time is decremented by double in seconds, DvTime -= DvTime gives
        a non-valid time, but is useful as an intermediate step in a
        chain of operations).</small></big><br>
    <br>
    <big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">operator*=</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span>&nbsp;
        double*=(double,int),&nbsp; int*=(int,double), </small></big><span style="font-family: Helvetica,Arial,sans-serif;">DvTime</span><big style="font-family: Helvetica,Arial,sans-serif;"><small>*=(double)&nbsp;








        (useful as an intermediate step in a chain of operations). <span style="font-weight: bold;"><br>
          <br>
        </span></small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><span style="font-weight:
          bold;">operator/=</span>&nbsp; double/=(double,int),&nbsp;
        int/=(int,double), </small></big><span style="font-family:
      Helvetica,Arial,sans-serif;">DvTime</span><big style="font-family:
      Helvetica,Arial,sans-serif;"><small>/=(double)&nbsp; (useful as an
        intermediate step in a chain of operations). <br>
        <br>
      </small></big><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void
        apply_mask(DvMask &amp;msk)</span> method will remove records
      from the calling object (and its xrefs) according to whether the
      corresponding entry in <span style="font-weight: bold;">msk</span>
      is true (keep) or false (remove). If the size of the mask does not
      match the sequence length, then this method does nothing other
      than set the object's error status.<br>
    </span><br>
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Modifying
      Operators (DvObject args)</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">The</span><span style="font-family: Helvetica,Arial,sans-serif;">Operators are
      also available to operate on DvObject arguments, where the
      following type conventions apply:</span><br>
    <big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"><br>
          operator+=(DvObject&amp;)</span>&nbsp; valid for double+=all
        (event adds duration, </small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small>DvTime += DvTime gives a
        non-valid time, but is useful as an intermediate step in a chain
        of operations</small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small>), int+=all, </small></big><span style="font-family: Helvetica,Arial,sans-serif;">DvTime</span><big style="font-family: Helvetica,Arial,sans-serif;"><small>+=double
        (the time is incremented by double, default is seconds), </small></big><span style="font-family: Helvetica,Arial,sans-serif;">DvString+=all
      (text equivalent appended to each string; this differs from
      +=DvString which adds string to the end of a sequence of strings)<span style="font-weight: bold;">.<br>
        <br>
      </span></span><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><span style="font-weight:
          bold;">operator-</span></small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><span style="font-weight:
          bold;">=(DvObject&amp;)</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span>&nbsp; valid for
        double-=(double,int),&nbsp; int-=(int,double), </small></big><span style="font-family: Helvetica,Arial,sans-serif;">DvTime</span><big style="font-family: Helvetica,Arial,sans-serif;"><small>-=(double,
        DvTime)&nbsp; (the time is decremented by double in seconds,
        DvTime -= DvTime gives a non-valid time, but is useful as an
        intermediate step in a chain of operations).</small></big><br>
    <br>
    <big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">operator*</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">=(DvObject&amp;)</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span> </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>valid for
      </small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small>double*=(double,int),&nbsp;
        int*=(int,double), </small></big><span style="font-family:
      Helvetica,Arial,sans-serif;">DvTime</span><big style="font-family:
      Helvetica,Arial,sans-serif;"><small>*=(double)&nbsp; (useful as an
        intermediate step in a chain of operations). The resultant array
        dimension is the same as the first argument if the second is a
        single value. Otherwise the array dimensions must be conformal,
        and the resulting dimensions satisfy the rules of matrix
        multiplication.<span style="font-weight: bold;"><br>
        </span></small></big><br>
    <big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">operator/</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">=(DvObject&amp;)</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span> </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>valid for
      </small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small>double/=(double,int),&nbsp;
        int/=(int,double), </small></big><span style="font-family:
      Helvetica,Arial,sans-serif;">DvTime</span><big style="font-family:
      Helvetica,Arial,sans-serif;"><small>/=(double)&nbsp; (useful as an
        intermediate step in a chain of operations). The resultant array
        dimension must be the same as <span style="font-weight: bold;">this</span>,
        so division by a single value only is allowed. <br>
      </small></big><br>
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Binary
      Operators</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">These all
      return DvObject* with the same type and dimensions of the first
      object (except <span style="font-weight: bold;">operator*</span>
      which may change the result dimension). <br>
      Operations may be with a single value or array, or with a
      sequence. In the case of a sequence, the sequences must be of the
      same length or be able to be joined onto the first argument.<br>
      <br>
      They are valid respectively for the specified data types below:</span><br>
    <big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"><br>
          operator+</span>&nbsp; double/all (event adds duration, </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>DvTime +=
        DvTime gives a non-valid time, but is useful as an intermediate
        step in a chain of operations</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>),
        int/all, </small></big><span style="font-family:
      Helvetica,Arial,sans-serif;">DvTime</span><big style="font-family:
      Helvetica,Arial,sans-serif;"><small>/double (the time is
        incremented by double, default is seconds), </small></big><span style="font-family: Helvetica,Arial,sans-serif;">DvString</span>/<span style="font-family: Helvetica,Arial,sans-serif;">all (text
      equivalent appended to string)<span style="font-weight: bold;">.<br>
        <br>
      </span></span><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><span style="font-weight:
          bold;">operator-</span>&nbsp; double/(double,int),&nbsp;
        int/(int,double), </small></big><span style="font-family:
      Helvetica,Arial,sans-serif;">DvTime</span><big style="font-family:
      Helvetica,Arial,sans-serif;"><small>/(double, DvTime)&nbsp; (the
        time is decremented by double in seconds, DvTime -= DvTime gives
        a non-valid time, but is useful as an intermediate step in a
        chain of operations).</small></big><br>
    <br>
    <big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">operator*</span>
        double/(double,int),&nbsp; int/(int,double), </small></big><span style="font-family: Helvetica,Arial,sans-serif;">DvTime</span><big style="font-family: Helvetica,Arial,sans-serif;"><small>/(double)&nbsp;









        (useful as an intermediate step in a chain of operations). The
        resultant array dimension is the same as the first argument if
        the second is a single value. Otherwise the array dimensions
        must be conformal, and the resulting dimensions satisfy the
        rules of matrix multiplication.<span style="font-weight: bold;"><br>
        </span></small></big><br>
    <big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">operator/</span>
        double/(double,int),&nbsp; int/(int,double), </small></big><span style="font-family: Helvetica,Arial,sans-serif;">DvTime</span><big style="font-family: Helvetica,Arial,sans-serif;"><small>/(double)&nbsp;








        (useful as an intermediate step in a chain of operations). The
        resultant array dimension must be the same as <span style="font-weight: bold;">this</span>, so division by a
        single value only is allowed. <br>
      </small></big><br>
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Vector
      Operators</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">These all
      operate on 3-vector objects.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
      &nbsp;<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>getVecFromRLP()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Returns the RLP
      vector as a cartesian vector</span><span style="font-family:
      Helvetica,Arial,sans-serif;">. Assumes input theta in range [0,
      pi/2) and phi in range [0, 2pi)</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">.</span><span style="font-family: Helvetica,Arial,sans-serif;">These all operate
      on 3-vector objects.<br>
      &nbsp;<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>getVecFromRTP()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Returns the RTP
      vector as a cartesian vector</span><span style="font-family:
      Helvetica,Arial,sans-serif;">. Assumes input latitude in range
      [-pi/2,pi/2) and phi in range [0,2pi)</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">.</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
    </span><br>
    <span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>dot(DvObject_var
      &amp;obj)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> Takes the dot (inner) product of
      records in <span style="font-weight: bold;">this</span> with
      those of <span style="font-weight: bold;">obj</span> (double
      three Vectors only)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;">.</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>vec(DvObject_var
      &amp;obj)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> Takes the vector (cross) product of
      records in <span style="font-weight: bold;">this</span> with
      those of <span style="font-weight: bold;">obj</span> (double
      three Vectors only). <br>
      In both cases <span style="font-weight: bold;">obj</span> may be
      a single vector or a sequence of vectors. Sequences will be joined
      automatically</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> if necessary.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><br>
    <br>
    <span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><br>
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Unary
      Operators</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">These methods
      all exist in two forms. One returns a copy if the object, <span style="font-weight: bold;">this</span>, with the data changed
      according to the standard mathematical definitions, while the
      other modifies the object itself and is declared void. Units are
      modified where possible, and if the operation requires the data to
      be unitless (e.g. log) the error flag is set in the resulting data
      if it has units, but the operation is completed anyway.<br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>sqrt()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Square root
      (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
      void sqrtThis()</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Square root <span style="font-weight: bold;">this</span> object</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>abs()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Absolute value
      (double , int)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> positive</span><span style="font-family: Helvetica,Arial,sans-serif;"> part of scalar
      or elements of an array, but gives magnitude of vector.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      void absThis()</span>&nbsp;<span style="font-family:
      Helvetica,Arial,sans-serif;">Absolute value</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span> object</span> <span style="font-family: Helvetica,Arial,sans-serif;">positive</span><span style="font-family: Helvetica,Arial,sans-serif;"> part of scalar
      or elements of an array</span><span style="font-family:
      Helvetica,Arial,sans-serif;">, magnitude of vector (object
      dimension changes)</span><span style="font-family:
      Helvetica,Arial,sans-serif;">.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>log()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Natural
      logarithm (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of scalar or elements of an array.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"> Sets the error text in the object has units<br>
      void logThis()</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Natural logarithm&nbsp; of</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span> object</span>&nbsp;<span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of scalar or
      elements of an array</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;">.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>log10()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Logarithm to
      base 10 (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of scalar or elements of an array.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"> Sets the error text in the object has units<br>
      void log10This()</span>&nbsp;<span style="font-family:
      Helvetica,Arial,sans-serif;">Logarithm to base 10</span><span style="font-family: Helvetica,Arial,sans-serif;"> of</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span> object</span>&nbsp;<span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of scalar or
      elements of an array</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;">.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>inverse()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Inverse (double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of scalar or
      elements of an array.</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"> <br>
      void inverseThis()</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Inverse of</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span> object</span>&nbsp;<span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of scalar or
      elements of an array</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;">.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>chgSign()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Changes sign
      (double, int)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of scalar or elements of an array.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"> <br>
      void </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">chgSign</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">This()</span> <span style="font-family: Helvetica,Arial,sans-serif;">Changes sign</span><span style="font-family: Helvetica,Arial,sans-serif;"> of</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span> object</span>&nbsp;<span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of scalar or
      elements of an array</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;">.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>exp()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Take exponential
      of data elements (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;">.</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"> <br>
      void exp</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">This()</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Take exponential of data elements
      (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span>
      object</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;">.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">DvObject</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>trace()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes trace of a
      2D square matrix&nbsp; (double, int)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"> </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
    </span><br>
    <span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>minusStart()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Subtracts the
      first record from every record. When applied to a sequence of
      DvTime objects (timetags) it will return seconds since start of
      the sequence as double objects.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"> <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">double max()</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> Returns the maximum value in the
      object.</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"> <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">double min()</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> Returns the minimum value in the
      object.</span><br>
    <br>
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Other Basic
      Operators</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>power(double p)</span><span style="font-family: Helvetica,Arial,sans-serif;"> raises data
      values</span><span style="font-family:
      Helvetica,Arial,sans-serif;">(double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"> to power
      p,&nbsp; </span><span style="font-family:
      Helvetica,Arial,sans-serif;">for each scalar or element of an
      array.</span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"> <br>
      void power</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">This(double p)</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Raises data values</span><span style="font-family: Helvetica,Arial,sans-serif;">(double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"> of</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span> object </span><span style="font-family: Helvetica,Arial,sans-serif;">to power p,&nbsp;
    </span> <span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> for each scalar
      or element of an array</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;">.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>power(int p)</span><span style="font-family: Helvetica,Arial,sans-serif;"> Raises data
      values </span><span style="font-family:
      Helvetica,Arial,sans-serif;">(double or int)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;">to power p,&nbsp;</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"> for each scalar
      or element of an array.</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
      void power</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">This(int p)</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Raises data values</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;">(double or int) </span><span style="font-family: Helvetica,Arial,sans-serif;">of</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span> object </span><span style="font-family: Helvetica,Arial,sans-serif;">to power p,&nbsp;
    </span> <span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> for each scalar
      or element of an array</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;">.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>remainder(double d)</span><span style="font-family: Helvetica,Arial,sans-serif;"> Remainder after
      dividing by d (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> </span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;">for scalar or each element of an
      array</span><span style="font-family: Helvetica,Arial,sans-serif;">.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"> <br>
      void </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">remainder</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">This(double d)</span>
    <span style="font-family: Helvetica,Arial,sans-serif;">Remainder
      after dividing</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span>
      object</span>&nbsp;<span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> </span><span style="font-family:
      Helvetica,Arial,sans-serif;">by d (double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">for scalar or
      each element of an array</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;">.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>remainder(</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject_var &amp;arg</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">)</span><span style="font-family: Helvetica,Arial,sans-serif;"> Remainder after
      dividing by arg (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;">.</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"> <br>
      void </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">remainder</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">This(</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject_var &amp;arg</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">)</span> <span style="font-family: Helvetica,Arial,sans-serif;">Remainder after
      dividing</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span>
      object</span>&nbsp;<span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> </span><span style="font-family:
      Helvetica,Arial,sans-serif;">by arg (double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">.</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"></span><br>
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Trig and Angle
      Operators</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"> </span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;">All trig functions assume radians </span><span style="font-family: Helvetica,Arial,sans-serif;">if there is no
      SI_Conversion attribute available, otherwise the data are
      converted to radians if possible.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> Inverse Trig functions take a bool
      argument, <span style="font-weight: bold;">indeg</span>,
      specifying if the output is in radians (false, default) or degrees
      (true). All trig operators trap inputs out of valid range and set
      the result to DvNaN and an error message. Periodic functions are
      handled modulo 2 pi, but inverses are in the range (-pi/2, pi/2).
      The exception is atan2() which returns values in (-pi, pi).</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>sin()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes
      trigonometric sine (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of scalar or elements of an array. </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      void sinThis()</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Takes trigonometric sine (double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span> object</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> for </span><span style="font-family: Helvetica,Arial,sans-serif;">scalar or
      elements of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> array</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">. </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>cos()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes
      trigonometric cosine (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of scalar or elements of an array. </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      void cosThis()</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Takes trigonometric cosine (double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span> object</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> for </span><span style="font-family: Helvetica,Arial,sans-serif;">scalar or
      elements of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> array</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>tan()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes
      trigonometric tangent (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of scalar or elements of an array. </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      void tanThis()</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Takes trigonometric tangent (double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span> object</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> for </span><span style="font-family: Helvetica,Arial,sans-serif;">scalar or
      elements of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> array</span><span style="font-family: Helvetica,Arial,sans-serif;">. </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>cot()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes
      trigonometric cotangent (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of scalar or elements of an array. </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      void cotThis()</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Takes trigonometric cotangent
      (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span>
      object</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> for </span><span style="font-family: Helvetica,Arial,sans-serif;">scalar or
      elements of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> array</span><span style="font-family: Helvetica,Arial,sans-serif;">. </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>asin(bool indeg)</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes inverse of
      trigonometric sine (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of scalar or elements of an array. </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      void asinThis(bool indeg)</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Takes</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> inverse of</span><span style="font-family: Helvetica,Arial,sans-serif;"> trigonometric
      sine (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span>
      object</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> for </span><span style="font-family: Helvetica,Arial,sans-serif;">scalar or
      elements of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> array</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">. </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>acos(bool indeg)</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes</span><span style="font-family: Helvetica,Arial,sans-serif;"> inverse of</span><span style="font-family: Helvetica,Arial,sans-serif;"> trigonometric
      cosine (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of scalar or elements of an array. </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      void acosThis(bool indeg)</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Takes</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> inverse of</span><span style="font-family: Helvetica,Arial,sans-serif;"> trigonometric
      cosine (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span>
      object</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> for </span><span style="font-family: Helvetica,Arial,sans-serif;">scalar or
      elements of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> array</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>atan(bool indeg)</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes</span><span style="font-family: Helvetica,Arial,sans-serif;"> inverse of</span><span style="font-family: Helvetica,Arial,sans-serif;"> trigonometric
      tangent (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of scalar or elements of an array. </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      void atanThis(bool indeg)</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Takes</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> inverse of</span><span style="font-family: Helvetica,Arial,sans-serif;"> trigonometric
      tangent (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span>
      object</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> for </span><span style="font-family: Helvetica,Arial,sans-serif;">scalar or
      elements of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> array</span><span style="font-family: Helvetica,Arial,sans-serif;">. </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>acot(bool indeg)</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes</span><span style="font-family: Helvetica,Arial,sans-serif;"> inverse of</span><span style="font-family: Helvetica,Arial,sans-serif;"> trigonometric
      cotangent (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of scalar or elements of an array. </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      void acotThis(bool indeg)</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Takes</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> inverse of</span><span style="font-family: Helvetica,Arial,sans-serif;"> trigonometric
      cotangent (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span>
      object</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> for </span><span style="font-family: Helvetica,Arial,sans-serif;">scalar or
      elements of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> array</span><span style="font-family: Helvetica,Arial,sans-serif;">. </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>sinh()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes
      trigonometric sine (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of scalar or elements of an array. </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      void sinhThis()</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Takes trigonometric sine (double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span> object</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> for </span><span style="font-family: Helvetica,Arial,sans-serif;">scalar or
      elements of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> array</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">. </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>cosh()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes hyperbolic
      cosine (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of scalar or elements of an array. </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      void coshThis()</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Takes </span><span style="font-family: Helvetica,Arial,sans-serif;">hyperbolic</span><span style="font-family: Helvetica,Arial,sans-serif;"> cosine (double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span> object</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> for </span><span style="font-family: Helvetica,Arial,sans-serif;">scalar or
      elements of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> array</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>tanh()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes </span><span style="font-family: Helvetica,Arial,sans-serif;">hyperbolic</span><span style="font-family: Helvetica,Arial,sans-serif;"> tangent (double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of scalar or
      elements of an array. </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
      void tanhThis()</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Takes </span><span style="font-family: Helvetica,Arial,sans-serif;">hyperbolic</span><span style="font-family: Helvetica,Arial,sans-serif;"> tangent (double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span> object</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> for </span><span style="font-family: Helvetica,Arial,sans-serif;">scalar or
      elements of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> array</span><span style="font-family: Helvetica,Arial,sans-serif;">. </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>coth()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes </span><span style="font-family: Helvetica,Arial,sans-serif;">hyperbolic</span><span style="font-family: Helvetica,Arial,sans-serif;"> cotangent
      (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of scalar or elements of an array. </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      void cothThis()</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Takes </span><span style="font-family: Helvetica,Arial,sans-serif;">hyperbolic</span><span style="font-family: Helvetica,Arial,sans-serif;"> cotangent
      (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span>
      object</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> for </span><span style="font-family: Helvetica,Arial,sans-serif;">scalar or
      elements of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> array</span><span style="font-family: Helvetica,Arial,sans-serif;">. </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>asinh()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes inverse of
    </span><span style="font-family: Helvetica,Arial,sans-serif;">hyperbolic</span><span style="font-family: Helvetica,Arial,sans-serif;"> sine (double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of scalar or
      elements of an array. </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
      void asinhThis()</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Takes</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> inverse of</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;">hyperbolic</span><span style="font-family: Helvetica,Arial,sans-serif;"> sine (double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span> object</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> for </span><span style="font-family: Helvetica,Arial,sans-serif;">scalar or
      elements of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> array</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">. </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>acosh()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes</span><span style="font-family: Helvetica,Arial,sans-serif;"> inverse of</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;">hyperbolic</span><span style="font-family: Helvetica,Arial,sans-serif;"> cosine (double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of scalar or
      elements of an array. </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
      void acoshThis()</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Takes</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> inverse of</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;">hyperbolic</span><span style="font-family: Helvetica,Arial,sans-serif;"> cosine (double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span> object</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> for </span><span style="font-family: Helvetica,Arial,sans-serif;">scalar or
      elements of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> array</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>atanh()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes</span><span style="font-family: Helvetica,Arial,sans-serif;"> inverse of</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;">hyperbolic</span><span style="font-family: Helvetica,Arial,sans-serif;"> tangent (double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of scalar or
      elements of an array. </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
      void atanhThis()</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Takes</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> inverse of</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;">hyperbolic</span><span style="font-family: Helvetica,Arial,sans-serif;"> tangent (double)</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> of</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span> object</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> for </span><span style="font-family: Helvetica,Arial,sans-serif;">scalar or
      elements of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> array</span><span style="font-family: Helvetica,Arial,sans-serif;">. </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>acoth()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes</span><span style="font-family: Helvetica,Arial,sans-serif;"> inverse of</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;">hyperbolic</span><span style="font-family: Helvetica,Arial,sans-serif;"> cotangent
      (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of scalar or elements of an array. </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      void acothThis()</span> <span style="font-family:
      Helvetica,Arial,sans-serif;">Takes</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> inverse of</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;">hyperbolic</span><span style="font-family: Helvetica,Arial,sans-serif;"> cotangent
      (double)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">this</span>
      object</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"> for </span><span style="font-family: Helvetica,Arial,sans-serif;">scalar or
      elements of</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> array</span><span style="font-family: Helvetica,Arial,sans-serif;">. </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>toDeg()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Returns <span style="font-weight: bold;">this</span> object converted to
      degrees if in radians, and sets metadata accordingly.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">void toDegThis()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Converts <span style="font-weight: bold;">this</span> object to degrees if in
      radians, and sets metadata accordingly.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>toRad()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Returns <span style="font-weight: bold;">this</span> object converted to
      radians if in degrees, and sets metadata accordingly.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">void toRadThis()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Converts <span style="font-weight: bold;">this</span> object to radians if in
      degrees, and sets metadata accordingly.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;">The
      following operators are convenience calls to convert between 2D
      and 3D vector representations and should be self explanatory. X, Y
      and Z are the usual cartesian components, while R is radius
      (magnitude), L is latitude, T is theta (colatitude) and P is phy
      (azimuth). Radians are to be assumed unless the method contains
      _deg. Going from polar to cartesian the method will use the
      SI_Conversion attribute to determine whether the input is in
      radians or degrees.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var
      </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"> XYtoRP()</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
      void XYtoRPThis()</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var
      </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"> XYtoRP_deg()</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
      void XYtoRPThis_deg()</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> </span><br>
    <span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"> </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">DvObject</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"> RPtoXY()</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
      void RPtoXYThis()</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"></span><br>
    <span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"> </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">DvObject</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> XYZtoRPZ()<br>
      void &nbsp; XYZtoRPZThis()<br>
      DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>XYZtoRPZ_deg()<br>
      void &nbsp; XYZtoRPZ_degThis()<br>
      DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> RPZtoXYZ()<br>
      void &nbsp; RPZtoXYZThis()<br>
      &nbsp; <br>
      DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> XYZtoRTP()<br>
      void &nbsp; XYZtoRTPThis()<br>
      DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> XYZtoRTP_deg()<br>
      void &nbsp; XYZtoRTP_degThis()<br>
      DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> RTPtoXYZ()<br>
      void &nbsp; RTPtoXYZThis()<br>
      &nbsp; <br>
      DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> XYZtoRLP()<br>
      void &nbsp; XYZtoRLPThis()<br>
      DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> XYZtoRLP_deg()<br>
      void&nbsp;&nbsp; XYZtoRLP_degThis()<br>
      DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> RLPtoXYZ()<br>
      void &nbsp; RLPtoXYZThis()<br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Array
      Operators</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">These modify
      the arrays at every record, and replace the DEPEND_i attributes
      appropriately.<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> subDimension(size_t
      i, bool withXref=true)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> Operates on a 1D array by removing
      the element at position<b> i </b>in the array. The length of the
      dimension is reduced by 1. </span>
    <meta http-equiv="content-type" content="text/html; charset=windows-1252">
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">If <b>withXref</b>
        is true (default) xrefs are attached</span></span><span style="font-family: Helvetica,Arial,sans-serif;">. </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> subsetDim(size_t d,
      size_t from, size_t to)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> Takes the subset of the array </span><span style="font-family: Helvetica,Arial,sans-serif;">along dimension d
      between <span style="font-weight: bold;">from</span> and <span style="font-weight: bold;">to</span> inclusively. If <span style="font-weight: bold;">from</span> &gt; <span style="font-weight: bold;">to</span>, then the subarray is taken
      cyclicly, starting at <span style="font-weight: bold;">from</span>
      up to the end of the dimension then from zero to <span style="font-weight: bold;">to</span>. </span><span style="font-family: Helvetica,Arial,sans-serif;">If </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">from </span><span style="font-family:
      Helvetica,Arial,sans-serif;">== </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">to </span><span style="font-family: Helvetica,Arial,sans-serif;">then <span style="font-weight: bold;">sliceDim()</span> is called and the
      number of dimensions will be reduced by one.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> sliceDim(size_t d,
      size_t at)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> Takes a slice of the array at
      element <span style="font-weight: bold;">at</span> in</span><span style="font-family: Helvetica,Arial,sans-serif;"> dimension <span style="font-weight: bold;">d</span>. </span><span style="font-family: Helvetica,Arial,sans-serif;">The number of
      dimensions will be reduced by one, and <span style="font-weight:
        bold;">DIMENSION_i</span> will be adjusted for any remaining
      dimensions if necessary.</span><br>
    <br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> sumDim(size_t d,
      size_t from, size_t to, bool stripBad=true)</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes the sum of
      the array </span><span style="font-family:
      Helvetica,Arial,sans-serif;">along dimension <span style="font-weight: bold;">d</span> between <span style="font-weight: bold;">from</span> and <span style="font-weight: bold;">to</span> inclusively.&nbsp; </span><span style="font-family: Helvetica,Arial,sans-serif;">If </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">from </span><span style="font-family:
      Helvetica,Arial,sans-serif;">== </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">to </span><span style="font-family: Helvetica,Arial,sans-serif;">then <span style="font-weight: bold;">sliceDim()</span> is called. The
      number of dimensions will be reduced by one.</span><span style="font-family: Helvetica,Arial,sans-serif;"> If stripBad is
      true (default) then entries with fillvalues are not included in
      the sum. </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
    </span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> averageDim(size_t d,
      size_t from, size_t to, bool stripBad=true)</span><span style="font-family: Helvetica,Arial,sans-serif;"> Takes the
      average of the array </span><span style="font-family:
      Helvetica,Arial,sans-serif;">along dimension <span style="font-weight: bold;">d</span> between <span style="font-weight: bold;">from</span> and <span style="font-weight: bold;">to</span> inclusively.&nbsp; </span><span style="font-family: Helvetica,Arial,sans-serif;">If </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">from </span><span style="font-family:
      Helvetica,Arial,sans-serif;">== </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">to </span><span style="font-family: Helvetica,Arial,sans-serif;">then <span style="font-weight: bold;">sliceDim()</span> is called. The
      number of dimensions will be reduced by one.</span><span style="font-family: Helvetica,Arial,sans-serif;"> If stripBad is
      true (default) then entries with fillvalues are not included in
      the average (and the divisor adjusted accordingly). </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><br>
    <span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> unwrapDim(size_t d,
      size_t from, size_t to)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> Turns the dimension <span style="font-weight: bold;">d</span> </span><span style="font-family: Helvetica,Arial,sans-serif;">between <span style="font-weight: bold;">from</span> and <span style="font-weight: bold;">to</span> inclusively</span><span style="font-family: Helvetica,Arial,sans-serif;"> into record
      entries spread evenly over the time interval. The array dimension
      is effectively aliased to time.&nbsp;</span><span style="font-family: Helvetica,Arial,sans-serif;"> If <span style="font-weight: bold;">from &gt; to</span>, the elements are
      selected cyclicly, first in the range <span style="font-weight:
        bold;">(from, N)</span> inclusive then <span style="font-weight: bold;">(0, to)</span> inclusive. The number
      of dimensions will be reduced by one and the number of records
      will be multiplied by the number of rows selected, usually <span style="font-weight: bold;">(from - to + 1)</span>, but will be <span style="font-weight: bold;">(N - from + to + 1)</span> if <span style="font-weight: bold;">from &gt; to</span>.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> reverseDim(size_t d,
      size_t from, size_t to)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> Re-orders the array </span><span style="font-family: Helvetica,Arial,sans-serif;">along dimension <span style="font-weight: bold;">d</span> between <span style="font-weight: bold;">from</span> and <span style="font-weight: bold;">to</span> inclusively, such that the
      dimension runs from <span style="font-weight: bold;">to</span> to
      <span style="font-weight: bold;">from</span>.&nbsp; </span><span style="font-family: Helvetica,Arial,sans-serif;">If </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">from </span><span style="font-family:
      Helvetica,Arial,sans-serif;">== </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">to </span><span style="font-family: Helvetica,Arial,sans-serif;">then <span style="font-weight: bold;">sliceDim()</span> is called. It
      requires that <span style="font-weight: bold;">to &gt; from</span>,
      but application of a cyclic subset first allows for external range
      selection. The number of dimensions is unchanged, but dimension <span style="font-weight: bold;">d</span> has length <span style="font-weight: bold;">(to - from + 1)</span>.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvString getCommonText()</span><span style="font-family: Helvetica,Arial,sans-serif;"> returns a string
      representation of the common part in all elements of the valarray
      (comparison is done after conversion to DvString. This is not
      entirely robust and is used for providing suggestions for metadata
      only.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> det()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Returns the
      determinant of a square two dimensional array of doubles.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> adjoint()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Returns the
      adjoint of a square two dimensional array of doubles.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"> </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">DvObject_var
      transpose(bool withXref=true)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> Returns the transpose of any two
      dimensional array.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> An NxM array will become and MxN
      array. If <b>withXref</b> is true (default) xrefs are attached.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"> </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> matrixInverse()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Returns the
      inverse of a matrix</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> of doubles.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"> </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">DvObject</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> trace()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Returns the
      trace (sum of diagonal elements) of a square 2D array</span><span style="font-family: Helvetica,Arial,sans-serif;"> (int and double
      data only).</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"> </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> subMatrix(size_t i,
      size_t j, bool withXref=true)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> Returns the subMatrix formed by
      removing row <span style="font-weight: bold;">i</span> and column
      <span style="font-weight: bold;">j.</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"> If <b>with</b>Xref

        is true (default) xrefs are attached.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
        bold;"><br>
      </span></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><span style="font-family: Helvetica,Arial,sans-serif;
        font-weight: bold;"></span></span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            _var outerProduct</span></span>(DvObject_var&amp; arg)</span>
      Returns the outer product of matrix A with matrix B. Result has
      dimensions R(i,j,..., k,l,...) where A(i,j,...) and B(k,l,...).
      Objects with frames (e.g. vectors) must be in the same frame. <br>
      <br>
      Note that <b>Inner product</b> is the same as multiply and dot
      product as appropriate, and is not provided separately.<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
      </span></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">DvObject</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> element(size_t i)</span><span style="font-family: Helvetica,Arial,sans-serif;"> Returns a scalar
      (sequence) comprising element <span style="font-weight: bold;">i</span>
      of the array (dimensions are handled in C ordering with last index
      varying fastest)<span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;">.</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"> <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> cycleMod(int nstart,
      int n, int modn)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> Retur</span><span style="font-family: Helvetica,Arial,sans-serif;">ns an object with
      the </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">modn </span><span style="font-family:
      Helvetica,Arial,sans-serif;">elements starting at <span style="font-weight: bold;">nstart</span> moved cyclicly by n
      positions. The elements are moved only within the specified block.
      This will work on a matrix or scalar sequence and any data type.
      It performs only one cyclic move, and does NOT repeat for every
      record. <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
      <span style="font-weight: bold;">DvObject</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var


          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>
        sum()</span> Returns an object of the same dimensions, but
      summed over all records. The returned sequence size is 1.<br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var


          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>
        multElements(DvObject_var&amp; arg)</span> Returns an object of
      the same dimensions as <span style="font-weight: bold;">this</span>
      with the elements of <span style="font-weight: bold;">this</span>
      multiplied by the corresponding element in <span style="font-weight: bold;">arg</span>. The dimensions of <span style="font-weight: bold;">this</span> and <span style="font-weight: bold;">arg</span> must be the same.<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
        DvObject</span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>
        divideElements(DvObject_var&amp; arg)</span> Returns an object
      of the same dimensions as <span style="font-weight: bold;">this</span>
      with the elements of <span style="font-weight: bold;">this</span>
      divided by the corresponding element in <span style="font-weight:
        bold;">arg</span>. The dimensions of <span style="font-weight:
        bold;">this</span> and <span style="font-weight: bold;">arg</span>
      must be the same.<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span><br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;">Utilities








      are also provided to return components and array reduced objects
      using the QSAS data slot syntax for component selection.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;">In
      general within QSAS the</span><span style="font-family:
      Helvetica,Arial,sans-serif;">se are used by the slots themselves,
      and slot-&gt;getObject() is used to return whatever is selected.<br>
      They are provided here for completeness.</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">vector &lt;DvString&gt; available(DvString
      constraint=DV_NONE)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> lists the possible component options
      for a data object for the provided constraint. This is for use in
      QSAS slots.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject_var getObjComponent(DvString comp)</span><span style="font-family: Helvetica,Arial,sans-serif;"> general routine
      returns the object after component subsampling.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>
      getVectorComponent(DvString comp)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> returns the selected component of
      the vector subsetted on records if necessary.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject_var getTimeComponent(DvString comp)</span><span style="font-family: Helvetica,Arial,sans-serif;"> returns a time
      object according to the component selection.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>
      getIntervalComponent(DvString comp)</span><span style="font-family: Helvetica,Arial,sans-serif;"> returns the
      selected interval </span><span style="font-family:
      Helvetica,Arial,sans-serif;">object according to the component
      selection</span><span style="font-family:
      Helvetica,Arial,sans-serif;">.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject_var getArrayComponent(DvString comp)</span><span style="font-family: Helvetica,Arial,sans-serif;"> returns an a
      object with reduced dimensions according to the component
      selection.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>
      getTimeSubset(DvString comp)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> returns the </span><span style="font-family: Helvetica,Arial,sans-serif;">object subset
      according to the record selection</span><span style="font-family:
      Helvetica,Arial,sans-serif;">.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
      DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> getTimeAve(DvString
      comp)</span><span style="font-family: Helvetica,Arial,sans-serif;">
      returns the </span><span style="font-family:
      Helvetica,Arial,sans-serif;">object averaged according to the
      record selection</span><span style="font-family:
      Helvetica,Arial,sans-serif;">.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvEvent getTimeInterval(DvString comp)</span><span style="font-family: Helvetica,Arial,sans-serif;"> returns the time
      interval represented by the object and its component selection.<br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">slice_array &lt;double&gt;</span></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"> getDSlice(slice sl)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> used internally to access double
      data for use with valarrays.</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;"><br>
      </span></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void</span></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"> setSlice(slice sl, </span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">slice_array








        &lt;double&gt;</span></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> used internally to set double data
      (used with getDSlice).</span><span style="font-family:
      Helvetica,Arial,sans-serif;"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void</span></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"> setSliceDim(size_t d, size_t el, </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">slice_array &lt;double&gt;</span></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"> val)</span><span style="font-family: Helvetica,Arial,sans-serif;"> used internally
      to set double data (used with getDSlice) to set element</span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">el</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span> of dimension <span style="font-weight: bold;">d</span> for every record using the
      slice_array <span style="font-weight: bold;">val</span>, which
      must have the same number of elements as seqSize().</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
      Equivalent calls exist for int, DvString, DvTime and DvEvent data
      types, e.g. getSSLICE(std::slice) for DvStrings.<br>
      Additionally, two methods for double data type only are provided.<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">slice_array &lt;double&gt;</span></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"> elementValarray</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">(size_t i</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> used internally to access double
      data (used directly with double valarrays) to get element</span><span style="font-family: Helvetica,Arial,sans-serif;"> i</span><span style="font-family: Helvetica,Arial,sans-serif;"> of arrays for
      every record, will have the same number of elements as seqSize().</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">valarray &lt;double&gt;</span></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"> detValarray</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">(size_t arrayDim,
      size_t len</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">)</span><span style="font-family: Helvetica,Arial,sans-serif;"> used internally,
      returns the determinant of a matrix as a valarray.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif;
      color: rgb(153, 0, 0);"></span><span style="font-family:
      Helvetica,Arial,sans-serif;"><br>
      See also <span style="font-weight: bold;">DvMatrixEig</span> and
      <span style="font-weight: bold;">DvMinVariance</span> classes
      below for further matrix utilities.<br>
    </span><span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);"><br>
      Algorithms</span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;">These provide
      some more complex operations on objects, and generally take
      options controlling algorithm details.<br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> integrate(DvString
      &amp;gapMethod, DvString &amp;integralMethod)</span><span style="font-family: Helvetica,Arial,sans-serif;"> Returns a</span><span style="font-family: Helvetica,Arial,sans-serif;"> new object
      holding the integral of <span style="font-weight: bold;">this</span>
      object. </span><span style="font-family:
      Helvetica,Arial,sans-serif;">The argument </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">gapMethod</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> may be <span style="font-weight:
        bold;">DV_NN</span>,&nbsp;</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">DV_IGNORE_GAPS</span>
      or <span style="font-weight: bold;">DV_LINEAR</span>, which
      respectively refer to filling data gaps with the nearest neighbour
      values (to the half way point from either side), leaving gaps out
      of the integral entirely and linear filling across gaps.&nbsp; If
      <span style="font-weight: bold;">integralMethod</span> is set to <span style="font-weight: bold;">DV_DEF_INTEGRAL</span> the definite
      integral is taken over the entire supplied range, otherwise if </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">integralMethod</span> is set to <span style="font-weight: bold;">DV_INDEF_INTEGRAL</span> the</span><span style="font-family: Helvetica,Arial,sans-serif;"> return object is
      a sequence of the same length as <span style="font-weight: bold;">this</span>,
      and holds the accumulative integral from the start of the sequence
      to each record.</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><br>
      <br>
      DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>
      differentiate(DvString &amp;derivMethod, double GapSize)</span><span style="font-family: Helvetica,Arial,sans-serif;"> Returns a new
      object holding the derivative of <span style="font-weight: bold;">this</span>
      object. The argument </span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">derivMethod</span><span style="font-family: Helvetica,Arial,sans-serif;"> may be either </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DV_DERIV_3PT</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> (default) or </span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DV_DERIV_5PT</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> which result in 3 point or 5 point
      estimates respectively. The 5 point method requires regularly
      spaced data and will join on the fly onto a regular Depend_0 that
      it creates with the same data spacing as the first two records.
      The argument <span style="font-weight: bold;">gapSize</span> is
      taken as the separation between records that will be treated as a
      gap and excluded from the returned sequence. If <span style="font-weight: bold;">gapSize</span> is negative (default)
      then it is calculated as 1.5 times the separation between the
      first two records. The first and last records (and records either
      side of a gap) use a simple two point estimation.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> regression()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Returns a new
      object holding the straight line (2 data points and two time tags
      (or double depend_0 ) that best fits the data. </span><span style="font-family: Helvetica,Arial,sans-serif;">The slope,
      intersept on the y-axis and the goodness of fit (correlation
      coefficient) are attached to the returned object as xrefs.<br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>
      regression(DvObject_var &amp;x )</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> Returns</span><span style="font-family: Helvetica,Arial,sans-serif;"> a new object
      holding the straight line (2 data points and two time tags (or
      double depend_0 ) that best fits the data taking the argument <span style="font-weight: bold;">x</span> as the x-data (and <span style="font-weight: bold;">this</span> object providing the
      y-data). </span><span style="font-family:
      Helvetica,Arial,sans-serif;">The slope, intersept on the y-axis
      and the goodness of fit (correlation coefficient) are attached to
      the returned object as xrefs.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>
      mergeWith(DvObject_var &amp;dobj )</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> Returns</span><span style="font-family: Helvetica,Arial,sans-serif;"> a new object
      holding the data from <span style="font-weight: bold;">this</span>
      object merged with the data from <span style="font-weight: bold;">dobj</span>,
      interlaced if necessary, according to the values on the DEPEND_0
      (usually time tags). If one data sequence entirely precedes the
      other, then they are simply concatenated. The number of returned
      records is the sum of the number of records in the two input data
      objects minus the number of duplicate records. If a record is
      duplicated (e.g. same timetag in both objects) then the data from
      <span style="font-weight: bold;">this</span> object is used.</span><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;"></span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;">DvObject</span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>
      stripDuplicates(double tolerence )</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> Returns</span><span style="font-family: Helvetica,Arial,sans-serif;"> a new object
      holding the data from <span style="font-weight: bold;">this</span>
      object with duplicates removed. Records are considered duplicates
      if their DEPEND_0 value for the two records differ by less than <span style="font-weight: bold;">tolerence</span>. The input DEPEND_0
      is assumed monotonic (see <span style="font-weight: bold;">makeMonotonic()</span>).&nbsp;







    </span><br>
    <span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;"><br>
      DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> cleanObject()</span><span style="font-family: Helvetica,Arial,sans-serif;"> Returns</span><span style="font-family: Helvetica,Arial,sans-serif;"> a new object
      holding the data from <span style="font-weight: bold;">this</span>
      object with all records containing either a FILLVAL or NaN
      removed. This may have undesired effects in array data if one
      channel holds bad data, in which case subsetting on dimension
      first will be necessary (see, e.g. <span style="font-weight:
        bold;">subsetDim()</span> above).</span><br>
    <br>
    <span style="font-family: Helvetica,Arial,sans-serif; font-weight:
      bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> makeMonotonic()</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;">Returns</span><span style="font-family: Helvetica,Arial,sans-serif;"> a new object
      holding the data (and xrefs) sorted in increasing order of the
      Depend_0 xref (e.g. time tags). Duplicate time tags are not
      removed, see <span style="font-weight: bold;">stripDuplicates()</span>
      above.<br>
      <br>
    </span><span style="font-family: Helvetica,Arial,sans-serif;
      font-weight: bold;">DvObject</span><span style="font-family:
      Helvetica,Arial,sans-serif; font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">_var </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span> applyOrder(vector
      &lt;int&gt; &amp;order)</span><span style="font-family:
      Helvetica,Arial,sans-serif;"> </span><span style="font-family:
      Helvetica,Arial,sans-serif;">This is used internally by <span style="font-weight: bold;">makeMonotonic()</span>. </span><span style="font-family: Helvetica,Arial,sans-serif;">It returns</span><span style="font-family: Helvetica,Arial,sans-serif;"> a new object
      holding the data sorted into record order specified by the values
      of order. The size or order must match the length of <span style="font-weight: bold;">this-&gt;seqSize()</span>, and each
      record value between <span style="font-weight: bold;">0</span>
      and&nbsp; </span><span style="font-family:
      Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">this-&gt;seqSize()







        - 1</span> must occur exactly once. </span><br>
    <br>
    <br>
    <span style="font-weight: bold; font-family:
      Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Xref Handling</span><span style="font-weight: bold; font-family: Helvetica,Arial,sans-serif;
      color: rgb(153, 0, 0);"></span><br style="font-family:
      Helvetica,Arial,sans-serif;">
    <span style="font-family: Helvetica,Arial,sans-serif;"> </span><big style="font-family: Helvetica,Arial,sans-serif;"><small>Specific
        utilities for handling xrefs (attributes) are provided, and the
        DvNode class (below) rarely needs to be used explicitly.<br>
        <br>
      </small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small> <span style="font-weight:
          bold;">bool xref_exists( DvString xref_name )</span>&nbsp;</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small> <span style="font-weight: bold;"><br>
          bool xref_exists( const char* xref_name )</span> both return
        true if a xref with the specified name exists in the object's
        list of xrefs.</small></big><br>
    <big style="font-family: Helvetica,Arial,sans-serif;"><small> <span style="font-weight: bold;">DvNode *find_xref( DvString&amp;
          xref_name )</span><br>
      </small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><span style="font-weight:
          bold;">DvNode *find_xref(</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"> const char* xref_name</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"> ) </span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>both
        return a pointer to the named xref object. If the object does
        not exist this pointer will be NULL.&nbsp; It returns a pointer
        to the DvNode object with the specified name. Note, however,
        that the method </small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><span style="font-weight:
          bold;">get_xref() </span>below is usually the simplest method
        to use as it returns the DvObject_var pointer contained in the
        node.</small></big><br>
    <big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">DvObject_var get_xref( </span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">DvString</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"> xref_name )<br>
        </span></small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><span style="font-weight:
          bold;">DvObject_var get_xref( const char* xref_name )</span> </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span> both return a copy of the
        DvObject_var referenced. This method is safe in that a valid
        object is always returned, though if the xref does not exist it
        will be empty of data and will give <span style="font-weight:
          bold;">is_nil()</span> true. This is the normal way to access
        a xref of known name. The list of xrefs in the parent object is
        not modified, if the xref does not exist the returned DvObject
        is not added to the xref list.<span style="font-weight: bold;"></span></small></big><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"></span><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">void delete_xref( </span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">DvString</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"> xref_name</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"> )</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"><br>
          void delete_xref( </span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">const char* xref_name</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"> )</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span> both remove the DvNode
        object from the parent object's list of xrefs and deletes it, so
        the contained DvObject will be destroyed automatically if not
        referred to elsewhere, for example via a </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>DvObject_var








        in another object's list of xrefs</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>. It is <span style="font-weight: bold;">not</span> necessary to delete a
        xref before using change_xref(). <br>
        <span style="font-weight: bold;">void list_xref_names(
          vector&lt;DvString&gt;&amp; sl )</span> creates a vector
        containing all the xref names in the object's list. The vector
        sl must be created by the calling routine, and names are
        appended.<br>
        <span style="font-weight: bold;">void change_xref( </span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">DvString</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"> xref_name</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">, DvObject_var xref_obj)<br>
        </span></small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><span style="font-weight:
          bold;">void change_xref( </span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">const char* xref_name</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">, DvObject_var xref_obj)</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span> both locate the named xref
        and change its DvObject_var pointer to xref_obj. If the xref
        does not already exist it is created and added to the object's
        list of xrefs. If the target object is in the xref's own xref
        list a copy of it will be attached without its own xrefs to
        avoid infinite loops.<br>
      </small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><span style="font-weight:
          bold;">void change_xref( </span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">const char* xref_name</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">, DvString &amp;s)</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span> </small></big><br>
    <big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">void change_xref( </span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">const char* xref_name</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">, const char *cs)</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span> </small></big><br>
    <big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">void change_xref( </span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">const char* xref_name</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">, double d)</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span> <br>
      </small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><span style="font-weight:
          bold;">void change_xref( </span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">const char* xref_name</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">, int i)</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span> these overloaded versions
        are shortcuts and create the appropriate DvObject from the input
        data on the fly.<br>
      </small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><span style="font-weight:
          bold;">void copy_xrefs_from(DvObject_var&amp; from_obj)</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"><br>
          void copy_xrefs_from(DvObject&amp; from_obj)</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span> both copy all the xrefs
        from the object from_obj into this object (calls change_xref()).<br>
      </small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><span style="font-weight:
          bold;">void copy_xref_from(</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">DvString</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">&amp;</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"> name, DvObject_var&amp; from_obj)</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span><br>
      </small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><span style="font-weight:
          bold;">void copy_xref_from(const char* name, DvObject_var&amp;
          from_obj)</span></small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><br>
      </small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><span style="font-weight:
          bold;">void copy_xref_from(</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">DvString</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">&amp;</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"> name, DvObject&amp; from_obj)</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span><br>
      </small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small><span style="font-weight:
          bold;">void copy_xref_from(const char* name, DvObject&amp;
          from_obj)</span></small></big><big style="font-family:
      Helvetica,Arial,sans-serif;"><small> all copy the single xref
        called <span style="font-weight: bold;">name</span> from the
        object from_obj into this object (all call change_xref()).</small></big><br>
    <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvNode* first_xref()</span> returns a
      pointer to the first DvNode object (xref) in this DvObject. Note
      that the DvNode class contains the pointer DvNode * next, to
      enable traversing the linked list of all xrefs in this DvObject.
      The last xref in the list has next set to NULL, e.g.<br>
      <span style="font-family: Courier New,Courier,monospace;">DvNode
        *xref = xref_obj.first_xref();</span><br style="font-family:
        Courier New,Courier,monospace;">
      <span style="font-family: Courier New,Courier,monospace;">while(xref){&nbsp;&nbsp;&nbsp;








      </span><br style="font-family: Courier New,Courier,monospace;">
      <span style="font-family: Courier New,Courier,monospace;">&nbsp;
        cout &lt;&lt; xref-&gt;name() &lt;&lt; endl;</span><br style="font-family: Courier New,Courier,monospace;">
      <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;








        xref = xref-&gt;next;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </span><br style="font-family: Courier New,Courier,monospace;">
      <span style="font-family: Courier New,Courier,monospace;">}</span><br style="font-family: Courier New,Courier,monospace;">
      <br style="font-family: Helvetica,Arial,sans-serif;">
    </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool xref_in_graph(DvObject
        &amp;xref_obj)</span> returns true if this is in the argument's
      list of xrefs (recursively). Used by change_xref()</span>.<br>
    <big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">void ensureSIC( )</span> modifies
        the object xrefs to ensure that the essential numerical values
        have an SI_Conversion attribute (using that of <span style="font-weight: bold;">this</span> object if they are not
        already set). If <span style="font-weight: bold;">this</span>
        has no SI_Conversion it does nothing. Attributes affected are
        Delta_plus, Delta_minus, Scalemax, Scalemin, Validmax and
        Validmin.<br>
        <br>
        <br>
      </small></big>
    <div style="text-align: center;">
      <div style="text-align: left;"><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> </small></big><span style="font-weight: bold; font-family:
          Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Metadata
          Utilities</span><br style="font-family:
          Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;"> </span><big style="font-family: Helvetica,Arial,sans-serif;"><small>Specific










            utilities for handling specific useful metadata (CAA, CSDS
            and ISTP attributes) are provided. These are part of the
            DvObject class and </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small>used internally to ensure
            operations are allowed, and to perform conversions and
            metadata correction within operations. As such, when
            DvObject operators are used it is not necessary to call
            these methods explicitly as DvObject ensures metadata
            compliance where possible.</small></big><br>
        <big style="font-family: Helvetica,Arial,sans-serif;"><small> </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> <span style="font-weight: bold;">DvObject_var getDep0()</span> i</small></big><span style="font-family: Helvetica,Arial,sans-serif;">s simply a
          call to <span style="font-weight: bold;">get_xref(DEPEND_0)</span>.
        </span><big style="font-family: Helvetica,Arial,sans-serif;"><small>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> <span style="font-weight: bold;">bool hasTimeTags()</span>
            returns true if the Depend_0 xref points to a time type
            object.</small></big><span style="font-family:
          Helvetica,Arial,sans-serif;"></span><big style="font-family:
          Helvetica,Arial,sans-serif;"><small><br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> <span style="font-weight: bold;">DvObject_var getTimeTags() </span>returns








            a var pointer to this object if it is a time object, else
            Depend_0 if that is a time object</small></big><span style="font-family: Helvetica,Arial,sans-serif;"> else an
          empty var pointer. <br>
        </span><big style="font-family: Helvetica,Arial,sans-serif;"><small>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small> <span style="font-weight: bold;">DvEvent getTimeRange() </span>returns








            the DvEvent corresponding to the start and stop time of the
            time tags if they exist, otherwise the default DvEvent().</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> <span style="font-weight: bold;">bool getDataRange(int recFrom,
              int recTo, double &amp;min, double &amp;max)</span>
            returns the minimum and maximum value of the data between
            the specefied records for data of type double. Return is
            true if data is double and range found, else returns false.</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><br>
          </small></big><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool</span></span><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"> getDataRange(double &amp;min,
              double &amp;max) </span>finds the minimum and maximum
            value in the data object. Double and int data are just cast
            to double, and time objects return the Epoch2000 values (see
            DvTime). It returns true if successful, and false if the
            object is nil or the data type is not handled.<br>
          </small></big><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString








            getXrefText(DvString &amp;name)</span><br style="font-family: Helvetica,Arial,sans-serif; font-weight:
            bold;">
          <span style="font-family: Helvetica,Arial,sans-serif;
            font-weight: bold;"> </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString getXrefText(const char
            *name)</span> both return a DvString holding the content of
          the named attribute converted (if necessary) to text.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">int</span></span><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"> get_iFILL()</span>&nbsp;</small></big><span style="font-family: Helvetica,Arial,sans-serif;"> returns the
          fill value as an integer.<br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">
          Unit and SI_conversion handling utilities are used within
          DvObject operators to ensure units are used and modified
          correctly. There are three different unit systems that data
          can be converted to/from. The SI_conversion string specifies
          the units of the data object by means of a standard SI unit
          string and a conversion factor that would convert the data
          into the specified SI units (by multiplying the data by the
          conversion factor). A third unit system is the Base SI units
          that all recognised SI units can be converted into. Units and
          conversions can be reduced to this Base SI form to ensure that
          the underlying units are the same and that conversions are
          between the same unit base. <br>
          <br>
        </span><big style="font-family: Helvetica,Arial,sans-serif;"><small>
            <span style="font-weight: bold;">DvString getSIC(int i=0)</span>
            gets the SI_conversion string as a DvString, and if i is
            specified returns the ith element of the SI_Conversion
            string matrix (e.g. for an rlp vector, although this is
            rarely supported in data files). </small></big><span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">DvString getBaseSI()</span>
            returns the SI_conversion string in base SI form.</small></big><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">double convFactor()</span>
            returns the </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small>numeric </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>SI_conversion








            factor to convert data into its SI form, that is the
            numerical value preceding the '&gt;'.</small></big><span style="font-family: Helvetica,Arial,sans-serif;"> </span><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span></small></big><span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">double convFactorToBaseSI()</span>
            returns the </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small>numeric </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>SI_conversion








            factor to convert data into its base SI form. This is often
            the same as convFactor().</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"><br>
              double convFactorFrom(DvString &amp;SIC)</span> returns
            the </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small>numeric </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>SI_conversion








            factor to convert data from <b>SIC</b> units to this.</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">bool sameBaseSI(DvObject_var
              &amp;arg)</span> returns true if <b>this</b> and <b>arg</b>
            have equivalend base SI units</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small> ( e.g
            returns true for V / km and nT m / s). <br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">bool sameBaseSI(</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"><big style="font-family:
                Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">const char * SIstr</span></small></big>)</span>
            returns true if <b>this</b> and an SI_Conversion string <b>SIstr</b>
            have equivalend base SI units</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small> ( e.g
            returns true for V / km and nT m / s). </small></big><br>
        <big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">bool sameUnits(DvObject_var
              &amp;arg)</span> returns true if <b>this</b> and <b>arg</b>
            have the same base SI units and conversion factors</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">.<br>
            </span></small></big> <big style="font-family:
          Helvetica,Arial,sans-serif;"><small><span style="font-weight:
              bold;">bool sameUnits(const char * SIstr, int i=0)</span>
            returns true if <b>this</b> and</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><big style="font-family: Helvetica,Arial,sans-serif;"><small>
                an SI_Conversion string <b>SIstr </b></small></big>have








            the same base SI units and conversion factors. If <b>i </b>is








            specified the ith entry in the <b>SI_Conversion</b> string
            matrix of this object is used (e.g. for rlp vectors).</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"><br>
            </span></small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small><span style="font-weight:
              bold;">DvString getUnitsProduct(DvObject &amp;arg)</span>
            returns the concatenated UNITS string for <b>this</b> and <b>arg</b>.<br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small><span style="font-weight:
              bold;">DvString getUnitsRatio(DvObject &amp;arg)</span>
            returns the concatenated UNITS string for <b>this</b> and <b>1
              / arg</b>.<br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">DvString getUnitsPower(double
              p)</span> returns the UNITS string for <b>this</b> raised
            to the power p as "(unit)^p".</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small> <br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small><span style="font-weight:
              bold;">DvString getUnitsInverse(double p)</span> returns
            the UNITS string for <b>1 / </b><b>this</b>.</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">DvString getSICProduct(DvObject
              &amp;arg)</span> returns the SI_conversion string for <b>this</b>
            times <b>arg</b>.</small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> <br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small><span style="font-weight:
              bold;">DvString getSICRatio(DvObject &amp;arg)</span>
            returns the SI_conversion string for <b>this</b> / <b>arg</b>.</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">DvString getSICInverse()</span>
            returns the </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small>SI_conversion</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>
            string for the inverse of this object.</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small> <br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small><span style="font-weight:
              bold;">DvString getSICPower(double p)</span> returns the </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>SI_conversion</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>
            string for this raised to the power p.</small></big><br>
        <big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">bool hasUnits()</span> returns
            true if <span style="font-weight: bold;">this</span> has </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>any SI
            units after reduction to Base SI form. Used to determine
            whether it is valid to take log(), exp() <i>etc</i>. If
            SI_Conversion is not found returns false.</small></big><br style="font-family: Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">All








          the following coordinate system methods look for the CSDS
          Frame attribute as well as CAA COORDINATE_SYSTEM, </span><span style="font-family: Helvetica,Arial,sans-serif;">REPRESENTATION,</span><span style="font-family: Helvetica,Arial,sans-serif;">
          REPRESENTATION_1,</span><span style="font-family:
          Helvetica,Arial,sans-serif;"> and TENSOR_ORDER attributes.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString getFrameAttr()</span>
          returns the frame information in the CSDS syntax, e.g.
          vector&gt;gse_xyz.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString getFrame()</span>
          returns the coordinate system part of the frame, e.g. gse. </span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString getRep()</span> returns
          the representation string, e.g. xyz, rlp or rtp.</span> <br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">int getOrder()</span> returns the
          order of the object (0 for scalar or array, 1 for vector and 2
          for rank 2 tensor.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"></span><big style="font-family:
          Helvetica,Arial,sans-serif;"><small><span style="font-weight:
              bold;"><span style="font-family:
                Helvetica,Arial,sans-serif;"><span style="font-weight:
                  bold;"></span></span></span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"><span style="font-family:
                Helvetica,Arial,sans-serif;"><br>
              </span>bool sameFrame(</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">DvObject_var &amp;arg</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">)</span> re</small></big><span style="font-family: Helvetica,Arial,sans-serif;">turns true if
          <b>this</b> and <b>arg</b> are measured in the same reference
          frame.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"> <br>
        </span> <big style="font-family: Helvetica,Arial,sans-serif;"><small>
            <span style="font-weight: bold;">bool sameFrame(</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">DvString &amp;frame</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">)</span> re</small></big><span style="font-family: Helvetica,Arial,sans-serif;">turns true if
          <b>this</b> is measured in the same reference frame as <b>frame</b>
          (in CSDS syntax</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-family:
            Helvetica,Arial,sans-serif;">, e.g. vector&gt;gse_xyz</span>).</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span> <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString setFrameAttr(DvString
            frameAttr)</span> sets the FRAME, COORDINATE_SYSTEM, ORDER
          and REPRESENTATION from the frameAttr string in CSDS syntax,
          e.g. vector&gt;gse_xyz.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString setFrameAttr(DvString
            frame, DvString rep, int order)</span> sets the FRAME,
          COORDINATE_SYSTEM, ORDER and REPRESENTATION from the frame,
          representation and order. <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString setFrameProduct(</span></span><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">DvObject_var &amp;arg</span></small></big><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span> sets the FRAME,
          COORDINATE_SYSTEM, ORDER and REPRESENTATION appropriate after
          this object has been multiplied by arg.<br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">int getOrder()</span> returns the
          numeric value of the rank of a matrix. e.g. 3-vectors are rank
          1.<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool isThreeVector()</span>
          returns true if the Frame attribute (if present) contains
          vector, or (if absent) the array size is 3.</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool isVectorXYZ()</span> returns
          true if it is a cartesian three vector (uses getRep() and
          isThreeVector()).</span><span style="font-family:
          Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">
          void</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            ensureVectorXYZ()</span> converts <b>this</b> object into
          cartesian representation. Does nothing if already cartesian.</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool








            isDeg()</span> returns true if this object is measured in
          degrees (uses <b>sameUnits("1&gt;deg")</b>).</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            bool isRad()</span> returns true if this object is measured
          in radians (uses <b>sameUnits("1&gt;rad")</b>).</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> <br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool








            isAngle()</span> returns true if this object is measured in
          either degrees or radians. It checks both the SI_Conversion
          and Units attributes.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool








            isPhiAngle()</span> returns true if this object is an
          azimuthal angle (range &gt; pi or '"phi" or "azimut" used in
          describing it).</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString angleUnitStr</span></span></span>
          returns a DvString containing one of "deg", "rad" or "".</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            bool isVectDeg()</span> returns true if any component of
          this object is measured in degrees.</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            bool isVectRad()</span> returns true if </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">any
            component of </span>this object is measured in radians.</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> <br>
            DvObject_var angleMod(int angMax, DvString rad_deg)</span>
          returns <b>this</b> object </span><span style="font-family:
          Helvetica,Arial,sans-serif;">with its range converted from one
          range to another depending on the value of <b>angMax</b> as
          follows:<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">angMax








          = 360 converts into the range 0, 360.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          angMax = 180 converts into the range -180, 180.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;">angMax =
          90 converts between the ranges 0, 180 and -90, 90 (the
          algorithm is the same, so repeated application converts back).</span>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            <br>
            bool okDims(DvObject_var &amp;arg)</span> returns true if
          the <span style="font-weight: bold;">arg</span> array
          dimension matches that of <span style="font-weight: bold;">this</span>
          object, or the <span style="font-weight: bold;"> arg</span>
          array has one element.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool sameDims(DvObject_var
            &amp;arg)</span> returns true if <span style="font-weight:
            bold;">this</span> object and <span style="font-weight:
            bold;">arg</span> have arrays of identical dimensions.</span>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            bool conformalDims(DvObject_var &amp;arg)</span> returns
          true if <span style="font-weight: bold;">this</span> object
          is conformal for multiplication by <span style="font-weight:
            bold;">arg</span>.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span> Returns true</span><span style="font-family: Helvetica,Arial,sans-serif;"> if either
          object has arraySize() = 1, or last dimension of <span style="font-weight: bold;">this</span> is the same as first
          dimension of <span style="font-weight: bold;">arg</span>.<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool squareMat()</span> returns
          true if <span style="font-weight: bold;">this</span> object
          is a square matrix (2 dimensions and both the same).<br>
          <br>
        </span><span style="font-weight: bold; font-family:
          Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Error
          Handling</span><br style="font-family:
          Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;">All</span><big style="font-family: Helvetica,Arial,sans-serif;"><small>
            operators return a valid object (either the original object
            or a default single value of appropriate type), but if this
            happens an error message is appended to the returnd object's
            error list. Error handling methods are:</small></big> <br>
        <big style="font-family: Helvetica,Arial,sans-serif;"><small> </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> <span style="font-weight: bold;">void clearError()</span>
            empties the object's error list.</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> <span style="font-weight: bold;">void error(const char*flag)</span>
            appends the message flag to the object's error list.</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> <span style="font-weight: bold;">DvString getError(size_t i)</span>
            returns the error message at position i on the object's
            error list. Default is the last error appended.</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> <span style="font-weight: bold;">int nError()</span> returns the
            number of error messages on the object's error list. </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>Returns








            zero if no errors have been detected.<br>
          </small></big><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span> <span style="font-weight: bold; font-family:
          Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);">Sequence
          and Joining Utilities</span><br style="font-family:
          Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;">All DvObject
          operators check arguments are joined and will perform a
          default join automatically </span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-family:
            Helvetica,Arial,sans-serif;">(if necessary) </span>.
          However, joining first may be appropriate if something other
          than a default join is required, such as joining to regular
          timetags or boxcar averaging. <br>
        </span><big style="font-family: Helvetica,Arial,sans-serif;"><small>
            <br>
          </small></big><span style="font-family:
          Helvetica,Arial,sans-serif;">These are the same utilities that
          are used internally by the DvObject operators to ensure that
          data are correctly joined. In the following methods the
          DEPEND_0 variable may be either DvTime or double values. Data
          gaps are never removed in default operations as DVOS operators
          join on the fly if needed and binary operators require the
          result to be of the same length as the target.<br>
        </span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;">The
          default gap size used for linear interpolation is 1.5 times
          the target spacing, and gaps are linear filled by default
          while ends use nearest neighbour.<br>
          <br>
          The default boxcar uses a box of width twice the target
          spacing, and a minimum of 3 points in the box. If fewer than
          the minimum number of points fall inside the box, then the
          result is a gap. The gap handling default is linear inside a
          gap and nearest neighbour on the ends.<br>
          <br>
          The Nearest Neighbour gap default is to use nearest neighbour
          inside gaps and off the ends.<br>
        </span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">The default
            gap and join options can be overridden by attaching suitable
            xrefs first (see Join Options below) in which case care must
            be taken when setting </span><span style="font-family:
            Helvetica,Arial,sans-serif;">DV_GAP_OPTION to </span><span style="font-family: Helvetica,Arial,sans-serif;">DV_REMOVE
            as the result may have fewer records than the target. If
            multiple objects are to be joined to the same target with
            gaps removed, then <span style="font-weight: bold;">MultiJoin()</span>
            should be used (see <span style="font-weight: bold;">DvJoinList</span>
            class below) to ensure they share a common timeline with
            gaps in all inputs removed</span><span style="font-family:
            Helvetica,Arial,sans-serif;">. </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">In all
              cases, if gap handling is set to remove gaps, then the end
              handling will also remove gaps. </span></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject_var Join(DvObject
            &amp;dobj, bool withXrefs)</span>&nbsp; </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"> joins this
            object onto the Depend_0 of <span style="font-weight:
              bold;">dobj</span></span> if it exists, otherwise it uses
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">dobj</span></span></span>
          itself as target. It can thus be called with either a data
          object or DEPEND_0 object as argument. It uses the join option</span><span style="font-family: Helvetica,Arial,sans-serif;"> and gap
          handling</span><span style="font-family:
          Helvetica,Arial,sans-serif;"> most suitable to the data type
          and spacing. Linear join is used for numeric data types
          (double, int, time) unless the target spacing is more than
          twice the object's original DEPEND_0 spacing, in which case a
          boxcar is used. Nearest neighbour is used for string and event
          data types. The result is a var pointer to a new object
          resulting from <span style="font-weight: bold;">this</span>
          being joined onto <span style="font-weight: bold;">target</span>,
          which must be a sequence of either DvTime or double values. If
          withXrefs is true (default) the xrefs are attached and joined
          as necessary. </span><span style="font-family:
          Helvetica,Arial,sans-serif;"></span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"></span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;">The
          defaults are safe for most plugin use, and the single method <b>Join()</b>
          below is all that is needed.<br>
          <br>
        </span> <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
              Helvetica,Arial,sans-serif;"><span style="font-weight:
                bold;">_var </span></span><span style="font-family:
              Helvetica,Arial,sans-serif;"><span style="font-weight:
                bold;"></span></span> Join(DvObject_var &amp;dobj, bool
            withXrefs)</span>&nbsp; </span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-family:
            Helvetica,Arial,sans-serif;">is a convenience call taking a
            var pointer as argument. It calls </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">Join(DvObject &amp;dobj, bool
                withXrefs)</span>&nbsp;</span> above.<br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool isRegular(double
            &amp;spacing)</span> returns true if the data are equally
          spaced (DEPEND_0 object evenly spaced, e.g. regular time
          tags). The argument spacing holds the value of this spacing on
          return.<br>
          <br>
          <span style="font-weight: bold;">double</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> get_spacing()</span> returns
          (usually) the minimum separation between values, e.g. <br>
          <span style="font-family: Courier New,Courier,monospace;">double








            spacing = dobj-&gt;getDep0()-&gt;get_spacing();</span><br>
          This is assumed to be the nominal data spacing with data gaps
          ignored. It retains the sign of the spacing, so a monotonic
          decreasing series has a negative spacing (e.g. if Depend_0 is
          t0 - t ). The algorithm sets the spacing to be the difference
          between the first two entries in DEPEND_0, and then scans the
          sequence and if an absolute separation smaller than the
          absolute value of this spacing is found more than once, then
          the second of these values is used as the new spacing. This
          continues until all records are checked. This reduces the
          likelihood of being confused by data glitches. Any spacing
          less than 1.0e-20 is assumed to be a duplicate timetag and is
          ignored.&nbsp; <br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool&nbsp; isJoined(DvObject
            &amp;arg)</span> uses the Depend_0 of <b>arg</b> as the
          argument if it has one, otherwise takes <b>arg</b> itself as
          the argument. Compares the id of the Depend_0 of this object
          with the id of the argument. Returns true if the id values are
          the same, otherwise if either has no Depend_0, then <span style="font-weight: bold;">isJoined()</span> returns true if
          the sequence length of this object and the argument are the
          same, or the argument has a sequence length of one. Otherwise
          (id's differ and both have a DEPEND_0) </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">isJoined()</span> </span><span style="font-family: Helvetica,Arial,sans-serif;"> does a fuzzy
          comparison with each value of the Depend_0 and the target and
          returns true only if they are all within a small tolerence
          (1.e-10, good to picoseconds), otherwise returns false.<br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool&nbsp; same(DvObject
            &amp;arg)</span> is the equivalent call to <span style="font-weight: bold;">isJoined()</span> except that <span style="font-weight: bold;">this</span> object and <span style="font-weight: bold;">arg</span> are themselves the
          DEPEND_0 object. This is a convenience call when testing
          against a target set of timetags (or scalar DEPEND_0), e.g.<span style="font-family: Courier New,Courier,monospace;"> if(
            dep0-&gt;same(target_tt) )</span>...</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject_var&nbsp;
            linearJoin(DvObject &amp;target, bool withXrefs, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
              Helvetica,Arial,sans-serif;"><span style="font-weight:
                bold;">DvMask *Gmsk</span></span>=NULL)</span> </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"> joins
              this object onto the Depend_0 of <span style="font-weight: bold;">dobj</span></span> if it
            exists, otherwise it uses </span><span style="font-family:
            Helvetica,Arial,sans-serif;"><span style="font-family:
              Helvetica,Arial,sans-serif;"><span style="font-family:
                Helvetica,Arial,sans-serif;"><span style="font-weight:
                  bold;">dobj</span></span></span> itself as target. It
            can thus be called with either a data object or DEPEND_0
            object as argument.&nbsp; It </span>returns a var pointer
          to a new DvObject containing this linearly joined onto the
          target object which must be a sequence of either DvTime or
          double values. The xrefs of the argument are attached to the
          result (joined if necessary) if <b>withXrefs</b> is true (the
          default). Options for gap width and gap handling may be set as
          xrefs in the object prior to joining and propagate into the
          resultant object for chaining operations (see <b>Join Options</b>
          below). If the optional <b>DvMask</b> pointer is provided,
          the DvMask must be created before linearJoin() is called, but
          it will be resized inside linearJoin(). If provided it returns
          a mask of the same length as the target with true for records
          to be kept and false for those flagged as gaps. It is used by
          MultiJoin. If not provided, then records are removed inside
          linearJoin() as necessary if either gap or end handling is set
          to DV_REMOVE.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject_var&nbsp;
            boxcarJoin(DvObject &amp;target, bool withXrefs, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
              Helvetica,Arial,sans-serif;"><span style="font-weight:
                bold;">DvMask *Gmsk</span></span>=NULL)</span> </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"> joins
                this object onto the Depend_0 of <span style="font-weight: bold;">dobj</span></span> if it
              exists, otherwise it uses </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">dobj</span></span></span>
              itself as target. It can thus be called with either a data
              object or DEPEND_0 object as argument.&nbsp; It </span></span>returns





          a var pointer to a new DvObject containing <span style="font-weight: bold;">this</span> object boxcar joined
          onto the target object</span><span style="font-family:
          Helvetica,Arial,sans-serif;"> which must be a sequence of
          either DvTime or double values</span><span style="font-family:
          Helvetica,Arial,sans-serif;">. </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">The xrefs
            of the argument are attached to the result (joined if
            necessary) if <b>withXrefs</b> is true (the default)</span>.
          Options for gap width and gap handling may be set as xrefs in
          the object prior to joining and propagate into the resultant
          object for chaining operations (see </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><b>Join
              Options</b> </span>below).</span><span style="font-family: Helvetica,Arial,sans-serif;"> If the
          optional <b>DvMask</b> pointer is provided, the DvMask must
          be created before linearJoin() is called, but it will be
          resized inside linearJoin(). If provided it returns a mask of
          the same length as the target with true for records to be kept
          and false for those flagged as gaps. It is used by MultiJoin.
          If not provided, then records are removed inside linearJoin()
          as necessary if either gap or end handling is set to
          DV_REMOVE.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"></span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject_var&nbsp; nnJoin(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
              Helvetica,Arial,sans-serif;"><span style="font-weight:
                bold;">DvObject &amp;target, bool withXrefs, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
                  Helvetica,Arial,sans-serif;"><span style="font-weight:
                    bold;">DvMask *Gmsk</span></span>=NULL</span></span>)</span>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">oins
                  this object onto the Depend_0 of <span style="font-weight: bold;">dobj</span></span> if it
                exists, otherwise it uses </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">dobj</span></span></span>
                itself as target. It can thus be called with either a
                data object or DEPEND_0 object as argument.&nbsp; It </span></span>returns





            a var pointer</span> to a new DvObject containing <span style="font-weight: bold;">this</span> object nearest
          neighbour joined onto the target object </span><span style="font-family: Helvetica,Arial,sans-serif;">which must be
          a sequence of either DvTime or double values.</span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;">The xrefs
            of the argument are attached to the result (joined if
            necessary) if <b>withXrefs</b> is true (the default)</span>.
          Options for gap width and gap handling may be set as xrefs in
          the object prior to joining and propagate into the resultant
          object for chaining operations (see </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><b>Join
              Options</b> </span>below).</span><span style="font-family: Helvetica,Arial,sans-serif;"> If the
          optional <b>DvMask</b> pointer is provided, the DvMask must
          be created before linearJoin() is called, but it will be
          resized inside linearJoin(). If provided it returns a mask of
          the same length as the target with true for records to be kept
          and false for those flagged as gaps. It is used by MultiJoin.
          If not provided, then records are removed inside linearJoin()
          as necessary if either gap or end handling is set to
          DV_REMOVE.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"></span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">Note




          that xrefs will be joined using the same method as the data
          and this may not be appropriate for the data type. In rare
          cases it may be necessary<br>
          to join certain xrefs separately and attach after joining the
          data.<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          <span style="font-weight: bold;">Join Options</span> may be
          added as xrefs to the DvObjects to be joined. If they are not
          present defaults will be used.<br>
          The possibilities are:<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          <b>DV_JOIN_METHOD</b> can be DV_LINEAR, DV_NN or DV_BOXCAR,
          and this choice is propagated into the resulting object, so it
          may be specified at the start of a chain of operations, and
          will override the default algorithm in <b>Join()</b>.<br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><b>DV_GAP_WIDTH</b>
          as a double is the gap
          tolerence for linear and nearest neighbour joins. If this xref
          is not set the gap will be 1.5 times the target spacing.<br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><b>DV_BOX_WIDTH</b>
          as a double is the boxcar width for a boxcar join. If this xref
          is not set the boxcar width will be 2 times the target
          spacing. For a boxcar any interval with too few points (see </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><b>DV_MIN_BOXCAR)</b> will be treated as a gap, and </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"><b><span style="font-family: Helvetica,Arial,sans-serif;"><b>DV_GAP_WIDTH</b></span></b><span style="font-family: Helvetica,Arial,sans-serif;"> is ignored.<br>
    </span></span>&nbsp;<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><b>DV_MIN_BOXCAR</b>
          as an int is the minimum number of values acceptable to make
          up the boxcar (for a boxcar join). The default is 3, and if
          fewer records are found inside the box at a record, then that
          record is taken to be a gap.<br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><b>DV_GAP_OPTION</b>
          determines what join should do with gaps in the input data.
          Options are DV_LINEAR, DV_NN, DV_REMOVE, DV_FILL (use
          fillvalue) or DV_ZERO_FILL.<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">The








          default option for boxcar join is DV_LINEAR </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">The








          default option for linear join is </span><span style="font-family: Helvetica,Arial,sans-serif;">DV_LINEAR</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          The default option for nearest neighbour join is DV_NN</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><br>
          <span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><b>DV_END_OPTION</b>
          determines what join should do when data start after or end
          before</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-family:
            Helvetica,Arial,sans-serif;"> the target</span>. Options are
          DV_LINEAR, DV_NN, DV_REMOVE, DV_FILL (use fillvalue) or
          DV_ZERO_FILL.<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">The








          default option for boxcar join is DV_NN </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">The








          default option for linear join is </span><span style="font-family: Helvetica,Arial,sans-serif;">DV_NN</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          The default option for nearest neighbour join is DV_NN</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><br>
          <span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject_var</span></span><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"> interpAt(DvTime t)</span>
            returns a var pointer with the value(s) of </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">this</span> object interpolated
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small>at time t and converted to
            double if possible (see asDouble() for conversions). Returns
            0.0 if the object has no valid time tags. The returned
            object will have type double, sequence length 1 and array
            dimensions the same as the input object.<br>
            <br>
          </small></big><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject_var</span></span><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"> getCentres()</span> returns a
            var pointer holding the values of this as though they were
            centred between Delta_plus and Delta_minus.</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small>
            Usually this is applied to the timeline and returns the
            centre time tags.<br>
          </small></big><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void applyLinearFill</span></span><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">(DvMask &amp;mask)</span>
            applies the mask to this object. For records where mask is
            false the data value is linearly interpolated between the
            neighbouring valid data points. It permits linear filling of
            gaps for the boxcar where we require the interpolation to be
            between the boxcar averaged values, and which must therefore
            be done after the boxcar is complete.</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small> It is
            for internal use.<br>
            <br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small> <span style="font-weight: bold;"></span></small></big><br>
        <big style="font-family: Helvetica,Arial,sans-serif;"><small> <span style="font-weight: bold;"></span></small></big> </div>
    </div>
    <div style="text-align: center;"><span style="font-family:
        Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><a name="Join"></a>DvJoinList








          Class<br>
          <br>
        </span></span>
      <div style="text-align: left;"><span style="font-family:
          Helvetica,Arial,sans-serif;">The only purpose of this class is
          to permit joining of several DvObjects </span><span style="font-family: Helvetica,Arial,sans-serif;"> (Multijoin)
        </span><span style="font-family: Helvetica,Arial,sans-serif;">onto









          the same target object. It is a DvList containing a linked
          list of DvNode objects which are the data objects to be joined
          and their names. Multijoin differs from joining objects
          independently only in that where gaps are removed from any
          resultant object, the same gaps are removed form all returned
          objects, so that all the MultiJoined objects are on exactly
          the same time tags (or scalar DEPEND_0).&nbsp;&nbsp; <br>
          <br>
          <span style="font-weight: bold;">void append(DvString name,
            DvObject_var &amp;obj) </span>add an object and its name to
          the list (will be placed in a DvNode)<br>
          <span style="font-weight: bold;">DvString MultiJoin(
            DvObject_var&nbsp; &amp;target, DvJoinList&nbsp;
            &amp;retList) </span>does the join operation.&nbsp; The <span style="font-weight: bold;">target</span> object must be a
          sequence of either DvTime or double values.<br>
          <br>
          The <span style="font-weight: bold;">DvString</span> return
          value is either "Multi Join OK" or an error message.<br>
          <br>
          The <span style="font-weight: bold;">DvJoinList</span> object
          calling <span style="font-weight: bold;">MultiJoin()</span>
          must hold the input objects for joining as the linked list of
          <span style="font-weight: bold;">DvNodes</span>. An empty
          DvJoinList is passed into MultiJoin and will contain the
          joined objects as a linked list of DvNodes on return. <br>
          <br>
          Joining options may be added to the DvObjects to be joined as
          xrefs (see below). If they are not present the defaults will
          be used.<br>
          The possibilities are:<br>
          <br>
          DV_JOIN_METHOD = DV_LINEAR, DV_BOXCAR or DV_NN <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">Note








          that only double data can be boxcar joined, otherwise the
          option is ignored and Nearest Neighbour is used.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          Note also that only double, int and DvTime data can be linear
          joined, otherwise the option is ignored and Nearest Neighbour
          is used.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;">If not
          present, double, int and DvTime data default to linear join
          (DvString and DvEvents always use Nearest Neighbour).<br>
          <br>
          DV_GAP_WIDTH as a double must be the boxcar width (for a
          boxcar join) or the gap tolerence for linear and nearest
          neighbour joins. If this xref is not set the boxcar width will
          be 10 times the data spacing, while the gap will be 1.5 times
          the data spacing.<br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">DV_GAP_OPTION








          = DV_LINEAR, DV_NN, DV_REMOVE, DV_FILL or DV_ZERO_FILL<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">The








          default option for boxcar join is DV_ZERO_FILL </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">The








          default option for linear join is </span><span style="font-family: Helvetica,Arial,sans-serif;">DV_LINEAR</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          The default option for nearest neighbour join is DV_ZERO_FILL</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><br>
        <br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span>
        <div style="text-align: center;"><span style="font-family:
            Helvetica,Arial,sans-serif;"><span style="font-weight:
              bold;"><a name="Mask"></a>DvMask Class</span></span><br>
          <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span></div>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> <br>
          </span></span> <span style="font-family:
          Helvetica,Arial,sans-serif;">The <span style="font-weight:
            bold;">DvMask</span> class is a simple container for a <span style="font-weight: bold;">valarray &lt;bool&gt;</span><span style="font-weight: bold;"></span>. <br>
          <br>
          The DvObject method <span style="font-weight: bold;">void
            apply_mask(DvMask &amp;msk)</span> will remove records from
          the calling object (and its xrefs) according to whether the
          corresponding entry in <span style="font-weight: bold;">msk</span>
          is true (keep) or false (remove). If the size of the mask does
          not match the sequence length, then this method does nothing
          other than set the object's error status.<br>
          <br>
          There is an equivalent method <span style="font-weight:
            bold;">DvObject *</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">subSequence(DvMask








            &amp;msk)</span> in DvObject that returns a new object
          rather than modifying the object itself.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><br>
          The DvMask class has the following methods</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            <br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvMask(int n, bool ok=true)&nbsp;</span>
          This constructor creates a new mask</span><span style="font-family: Helvetica,Arial,sans-serif;"> of length <span style="font-weight: bold;">n</span></span><span style="font-family: Helvetica,Arial,sans-serif;"> and sets all
          entries to <span style="font-weight: bold;">ok</span>.</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> </span>Default is ok = true
          (keep).<span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            DvMask(DvMask &amp;msk)&nbsp;</span> This is a copy
          constructor that duplicates msk and its values.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t size()&nbsp;</span>
          Returns the length of the mask<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t resultSize()&nbsp;</span>
          Returns the number of true entries in the mask<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void resize(size_t n</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, bool ok=true</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)&nbsp;</span> Resizes the
          valarray to length n and sets them to ok. Default is true
          (keep).<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool operator[ ](size_t i )&nbsp;</span>
          Provides access to the valarray value at i. This is the actual
          element, and allows modification of the value.<br>
          <br>
          <br>
          <br>
        </span>
        <div style="text-align: center;"><span style="font-family:
            Helvetica,Arial,sans-serif;"><span style="font-weight:
              bold;"><a name="Node"></a>DvNode and DvList Classes</span><br>
            <br>
          </span><span style="font-family: Helvetica,Arial,sans-serif;"></span></div>
        <span style="font-family: Helvetica,Arial,sans-serif;">The <span style="font-weight: bold;">DvNode</span> </span><span style="font-family: Helvetica,Arial,sans-serif;">class is a
          container for a <span style="font-weight: bold;">DvObject_var</span>
          pointer and an associated <span style="font-weight: bold;">name</span>
          (the name of the object being held). <br>
          The <span style="font-weight: bold;">DvList</span> class
          contains a linked list of <span style="font-weight: bold;">DvNode</span>
          pointers, and methods to search and manipulate the list. It is
          used to hold the metadata (called <span style="font-weight:
            bold;">xrefs</span>, but attributes in CDF terminology)
          attached to a variable, the QSAS Working List, and any other
          list of objects for passing around the system (e.g.
          MultiJoin). <br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvNode</span></span><span style="font-family: Helvetica,Arial,sans-serif;"> pointers
          work as a linked list, so that each node holds the location of
          the next node in the list, or a NULL. <br>
          <br>
          The </span><span style="font-family:
          Helvetica,Arial,sans-serif;">DvObject class stores its xrefs
          (metadata) via a <span style="font-weight: bold;">DvList</span>
          object called <span style="font-weight: bold;">xrefs</span>.
          The first <span style="font-weight: bold;">DvNode</span> in
          this list holds the first xref, its name and links to the next
          xref, and so on. Since metadata can itself have metadata, this
          linkage could become circular, so the </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif; font-weight:
          bold;">DvObject::</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">change_xref()








          </span>method ensures that the target does not appear in the
          xref's list of xrefs (recursively). If a circular reference is
          found the a copy of the object without its list of xrefs is
          attached. <br>
          <br>
          There are three equivalent constructors for convenience:<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvNode(const char *name,
            DvObject_var obj) </span>where name is the node name (e.g.
          attribute name or Working List name) and obj is a var pointer
          to the data object</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            DvNode(string name, DvObject_var obj) </span>where name is
          the node name and obj is a var pointer to the data object</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            DvNode(DvString name, DvObject_var obj) </span>where name
          is the node name and obj is a var pointer to the data object<br>
          and an empty constructor.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"></span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"> <br>
          The attributes are usually created, accessed and modified
          through the methods in DvObject and other classes with linked
          lists, and use of the following low level methods is rare. <br>
        </span> <span style="font-family: Helvetica,Arial,sans-serif;"><br>
          The </span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvNode








          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;">methods </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            DvString&nbsp; name() </span></span><span style="font-family: Helvetica,Arial,sans-serif;">returns the
          attribute name</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            <br>
            DvObject_var&nbsp; obj</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">() </span>returns the var
          pointer to the data object<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void&nbsp; setName(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString name</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">) </span></span><span style="font-family: Helvetica,Arial,sans-serif;">sets (or
          changes) the attribute name</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            <br>
            void&nbsp; setObj</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject_var obj</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span> sets (or changes) the
          var data pointer </span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvNode&nbsp; *next</span> is the
          next node in the list (note it is a public pointer not a
          method) and is the normal way to step through a list.</span>)
        <br style="font-family: Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void&nbsp; toXML(ofsteam &amp;)</span>
          is the method used for save to an XML file (for save/restore)
          and is an internal used by DvList.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void&nbsp; fromXML(char *)</span>
          is the method used for extract from an XML file (for
          save/restore</span><span style="font-family:
          Helvetica,Arial,sans-serif;">) and is an internal used by
          DvList.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><br>
          <br>
          <br>
        </span> <span style="font-family: Helvetica,Arial,sans-serif;">The







        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvList </span></span><span style="font-family: Helvetica,Arial,sans-serif;">methods </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            DvList() </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;">Creates an empty list</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">.</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            DvNode&nbsp; *first() </span></span><span style="font-family: Helvetica,Arial,sans-serif;">returns a
          pointer to the first node in the linked list</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          <span style="font-weight: bold;">int size() </span>returns
          the number of nodes in the list <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvNode</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> *</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">makeNode</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">() </span>adds a new (empty)
          node to the start of the list and returns a pointer to it<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> remove</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">(DvString name) </span>removes
          the named node from the list and relinks appropriately<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> append</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">(DvString name, DvObject_var
            &amp;obj) </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;">adds a new node to the list
          (actually prepends) with this name. If the name exists an 'A'
          is added until a unique name found. The actual name used is
          returned.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvNode</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> *find</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString &amp;name</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">) </span>returns a pointer to
          the named node<span style="font-weight: bold;"> </span><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvNode</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> *find</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">const char *name</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">) </span>returns a pointer to
          the named node<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> clear</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">() </span>empties the list and
          sets the first node to NULL</span><br>
        <br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void&nbsp; toXML(ofsteam
            &amp;ofp, DvString ListName)</span> is the method used for
          save to an XML file (for save/restore) and is an internal used
          by DvObject and QSAS.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void&nbsp; fromXML(char *)</span>
          is the method used for extract from an XML file (for
          save/restore</span><span style="font-family:
          Helvetica,Arial,sans-serif;">) and is an internal used by </span><span style="font-family: Helvetica,Arial,sans-serif;">DvObject and
          QSAS</span><span style="font-family:
          Helvetica,Arial,sans-serif;">.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"></span><span style="font-family:
          Helvetica,Arial,sans-serif;"> See below.<br>
        </span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"> When the
          <span style="font-weight: bold;">DvList</span> goes out of
          scope it deletes the <span style="font-weight: bold;">DvNodes</span>
          in the list recursively. <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"> Note:
          higher level methods on the relevant <span style="font-weight: bold;">DvList</span> and its <span style="font-weight: bold;">DvNode</span> contents are
          provided in the parent classes (DvObject, DvJoinList and
          DvWorkingList).</span><br>
        <br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span>
        <div style="text-align: center;"><span style="font-family:
            Helvetica,Arial,sans-serif;"><span style="font-weight:
              bold;"><a name="XML"></a>XML Methods</span><br>
            <br>
          </span><span style="font-family: Helvetica,Arial,sans-serif;"></span></div>
        <span style="font-family: Helvetica,Arial,sans-serif;">A
          DvObject can be written and read as XML text.&nbsp; <span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;">The two
          methods (which handle all supported data types) are:<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void&nbsp; toXML(ofsteam
            &amp;ofp)</span> writes the object and recursively its
          metadata to an XML file.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void&nbsp; fromXML(char *)</span>
          populates an object from XML text.<br>
          <br>
          Since objects within QSAS are held on the Working List (a
          DvList) and their metadata are also (recursively) attached via
          a DvList,<br>
          it is never necessary to call these low level routines
          directly.<br>
          <br>
          To save a DvList (such as the Working List) could involve code
          such as the following...<br>
          &nbsp;&nbsp;&nbsp; <br style="font-family: Courier
            New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            DvList WL;</span><br style="font-family: Courier
            New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">...</span><br style="font-family: Courier New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            std::ofstream ofp;</span><br style="font-family: Courier
            New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            ofp.open("file.xml", std::fstream::out );</span><br style="font-family: Courier New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            WL.toXML(ofp, DvString("WORKING_LIST") ); </span><br style="font-family: Courier New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            ofp.close();</span><br>
          <br>
          This in turn could be read via...<br>
          <br>
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            DvList WL;<br>
            <br>
            ...<br>
            &nbsp;&nbsp;&nbsp; WL.clear(); // remove old list unless
            data to be appended<br>
            <br>
            &nbsp;&nbsp;&nbsp; char * xml = readXML("file.xml"); //
            failure to read returns NULL</span><br style="font-family:
            Courier New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            size_t start;</span><br style="font-family: Courier
            New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            DvString </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-family: Courier
            New,Courier,monospace;">tag</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Courier New,Courier,monospace;">;</span><br style="font-family: Courier New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            char *ptr = getNextTag(xml, start, tag);</span><br style="font-family: Courier New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            while(ptr){</span><br style="font-family: Courier
            New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            &nbsp;&nbsp;&nbsp; </span><span style="font-family: Courier
            New,Courier,monospace;">if(tag == "WORKING_LIST") {</span><br style="font-family: Courier New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DvList WL_temp;</span><br style="font-family: Courier New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; WL.fromXML(xml+start);</span><br style="font-family: Courier New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </span><span style="font-family: Courier New,Courier,monospace;"></span><br style="font-family: Courier New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            &nbsp;&nbsp;&nbsp; }<br>
            &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // else if() read any
            other tags in the XML text<br>
            ...<br>
            &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // get next tag<br style="font-family: Courier New,Courier,monospace;">
          </span><span style="font-family: Courier
            New,Courier,monospace;">&nbsp;&nbsp;&nbsp;
            &nbsp;&nbsp;&nbsp; xml = ptr;</span><br style="font-family:
            Courier New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            &nbsp;&nbsp;&nbsp; ptr = getNextTag(xml, start, tag);<br style="font-family: Courier New,Courier,monospace;">
          </span><span style="font-family: Courier
            New,Courier,monospace;">&nbsp;&nbsp;&nbsp; }<br>
            &nbsp;&nbsp;&nbsp; if(xml) delete xml;<br>
          </span><br>
          In the case of QSAS itself the Working List is created at the
          same time as populating the GUI and so the XML list is read
          into a temporary DvList first, then unpacked into the real WL
          via the internal QT aware calls...<br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            DvNode *node = WL_temp.first();</span><br style="font-family: Courier New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            while(node){</span><br style="font-family: Courier
            New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            &nbsp;&nbsp;&nbsp; QString name = node-&gt;name().c_str();</span><br style="font-family: Courier New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            &nbsp;&nbsp;&nbsp; QwuiPutOnWL(node-&gt;obj(), name, false);
            // false is don't replace</span><br style="font-family:
            Courier New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            &nbsp;&nbsp;&nbsp; node = node-&gt;next;</span><br style="font-family: Courier New,Courier,monospace;">
          <span style="font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;








            }</span></span><br>
        <br>
        <span style="font-family: Helvetica,Arial,sans-serif;">There are
          two read functions: <br>
          <span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">char *readXML(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString nameAndPath</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span> </span><span style="font-family: Helvetica,Arial,sans-serif;"> which opens
          the file and extracts the contents to</span><span style="font-family: Helvetica,Arial,sans-serif;"> a new char
          *. </span><span style="font-family:
          Helvetica,Arial,sans-serif;">Note that there is a constructor
          for a DvString from a const char *, so calls using quoted text
          such as </span><span style="font-family:
          Helvetica,Arial,sans-serif; font-weight: bold;">readXML</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">("/path/file")</span> are
          allowed.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">char *getNextTag(</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">char *xml, size_t &amp;start,
            DvString &amp;tag</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)
          </span>which steps through the tags in the XLM string,
          returning a pointer to just beyond the closing tag. A null
          terminator is inserted after the tag contents which are
          returned via the offset pointer start. The DvString tag
          returns the tag name.<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">These








          functions are provided within the DVOS library.&nbsp;<span style="font-weight: bold;"> <br>
            <br>
            Note</span> that the QSAS GUI save/restore operations are
          written using the QT supplied XML methods. However, all DVOS
          data objects and lists use only the methods contained within
          the DVOS library, which is thus self contained. </span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;
          font-weight: bold;"></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span>
        <div style="text-align: center;"><span style="font-family:
            Helvetica,Arial,sans-serif; font-weight: bold;"><a name="String"></a>DvString
            Class</span><br style="font-family:
            Helvetica,Arial,sans-serif;">
        </div>
        <br style="font-family: Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;">The
          DvString class inherits from std::string but has additional
          methods<br>
          <br>
          The constructors are:<br>
          &nbsp;<span style="font-weight: bold;">DvString(void)</span>
          constructs an empty string<br>
          <span style="font-weight: bold;">&nbsp;DvString( const
            string&amp; s )</span> constructs a copy of s<br>
          <span style="font-weight: bold;">&nbsp;DvString( const
            DvString&amp; ds )</span> constructs a copy of ds<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">&nbsp;<span style="font-weight: bold;">DvString( const char* cs )</span>
          constructs a copy of cs</span><span style="font-family:
          Helvetica,Arial,sans-serif;">&nbsp; <span style="font-weight:
            bold;"><br>
            &nbsp;DvString( const char c )</span> constructs a DvString
          of one character set to c</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"> <br>
          and are matched by equivalent assignment operators<br>
          <span style="font-weight: bold;">DvString&amp; operator=(
            const string&amp; s )</span> etc.<br>
          <br>
          There are further assignment operator</span><span style="font-family: Helvetica,Arial,sans-serif;">s that set
          the string from a "quoted" string (quotes are removed)<br>
          <span style="font-weight: bold;">void setQuoted(&nbsp;
            string&amp; s )</span> </span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">void setQuoted(&nbsp; const char
            * cs )</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"> both of which set this string to
          the value of s or cs with enclosing quoted removed. If there
          are no enclosing quotes the string is set to the argument
          without change. Only the opening quote is tested, if present a
          closing quote is assumed and the last character removed.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"> <br>
          The methods<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">string str()</span> gives access
          to the object explicitly as a std::string <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span>
        <span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">bool blank()</span> returns true
          if the string comprises only quote, space and tab characters <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span>
        <span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">bool empty()</span> returns true
          if the string holds no characters </span><span style="font-family: Helvetica,Arial,sans-serif;"><br></span><span style="font-family: Helvetica,Arial,sans-serif;">
        </span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">bool isNumber()</span> returns true
          if the string comprises only a numeric value (only numbers or&nbsp; +, -, e, E, . ) </span><span style="font-family: Helvetica,Arial,sans-serif;">
        </span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;"><br>
bool isInt()</span> returns true
          if the string comprises only an integer numeric value (only numbers or&nbsp; +, - ) </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"> </span>
        <span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">char last()</span> returns the
          last character in the string</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">and the <span style="font-weight: bold;">operator &lt;&lt; </span>allows
          the string to be streamed using cout and similar.<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            <span style="color: rgb(153, 0, 0);">Substrings</span><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString








            trimmed()</span> returns a copy of the string with leadong
          and trailing spaces removed. <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString before(const char delim)</span>
          returns the substring ending before the first occurence of
          delim</span><span style="font-family:
          Helvetica,Arial,sans-serif;">. If delim is not found an empty
          DvString is returned.<span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            DvString before(const char *delim)</span> returns the
          substring ending before the first occurence of delim</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">. If delim is
          not found an empty DvString is returned.</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            DvString before(size_t posn)</span> returns the substring
          ending before posn</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">. If posn is
          beyond the end, the whole string is returned.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> DvString after(const char delim)</span>
          returns the substring starting after the first occurence of
          delim</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"></span><span style="font-family:
          Helvetica,Arial,sans-serif;">. If delim is not found an empty
          DvString is returned.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> DvString after(const char
            *delim)</span> returns the substring starting after the
          first occurence of delim</span><span style="font-family:
          Helvetica,Arial,sans-serif;"></span><span style="font-family:
          Helvetica,Arial,sans-serif;">. If delim is not found an empty
          DvString is returned.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            DvString after(</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t








            posn</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span>
          returns the substring starting after posn</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;">. </span><span style="font-family: Helvetica,Arial,sans-serif;">If posn is
          beyond the end, an empty DvString is returned.</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            DvString common(</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString








            &amp;str</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span>
          returns the common parts between <span style="font-weight:
            bold;">this</span> and <span style="font-weight: bold;">str</span><span style="font-family: Helvetica,Arial,sans-serif;">.</span>
          Restarts comparison at "(".</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            DvString between(const char *delim1, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">const char *delim2</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span> returns the substring
          starting after the first occurence of delim1 and ending before
          the first occurence of delim2. If either deilm is not found an
          empty string is returned.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            DvString back(const char *delim</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span> returns the substring
          starting after the first occurence of delim. If delim is not
          found, the whole string is returned.</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString








            front(const char *delim</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span> returns the substring
          ending before the first occurence of delim. If delim is not
          found, the whole string is returned.</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString








            replace(</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">const








            char *</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            str1, </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">const








            char *</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            str2</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span> returns a copy of <span style="font-weight: bold;">this</span> string with the first
          occurence of <span style="font-weight: bold;">str1</span>
          replaced by <span style="font-weight: bold;">str2</span>;</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString








            replaceAll(</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">const








            char *</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            str1, </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">const








            char *</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            str2</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span> returns a copy of <span style="font-weight: bold;">this</span> string with all
          occurences of <span style="font-weight: bold;">str1</span>
          replaced by <span style="font-weight: bold;">str2</span>;</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString








            replaceTokens(</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">const








            char * str, const char delim</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span> returns a copy of <span style="font-weight: bold;">this</span> string with the
          appropriate text from str as follows. If str contains a
          substring of the form <span style="font-weight: bold;">?str1=str2?</span>
          where <span style="font-weight: bold;">?</span> is the delim,
          then all occurences of <span style="font-weight: bold;">str1</span>
          in this string are replaced by <span style="font-weight:
            bold;">str2</span>. The string str may hold more than one
          token of the form </span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">?str1=str2?</span>
          and each is processed in turn in the order they appear in <span style="font-weight: bold;">str</span>.</span><span style="font-family: Helvetica,Arial,sans-serif;"> The default
          value of delim is '?'.<span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            <br>
          </span>Note that <span style="font-weight: bold;">front()</span>
          and <span style="font-weight: bold;">before()</span> differ
          only in the result when the delimiter is not found. Similarly
          for <span style="font-weight: bold;">back()</span> and <span style="font-weight: bold;">after()</span>.<span style="font-weight: bold;"><br>
          </span></span><br>
        <span style="font-family: Helvetica,Arial,sans-serif; color:
          rgb(153, 0, 0); font-weight: bold;">Conversions</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double toDouble()</span> returns
          the text as a double<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">int toInt()</span> returns the
          text as an int<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime toTime()</span> returns
          the text as a DvTime object<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvEvent toEvent()</span> returns
          the text as a DvEvent object</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><br>
          <span style="font-weight: bold;">void set(double val)</span><br style="font-weight: bold;">
        </span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">void set(int val)</span> both set
          the content of the DvString to the text equivalent of val
          using the free format specifiers <span style="font-weight:
            bold;">%g</span> and <span style="font-weight: bold;">%d</span>
          respectively.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"> <span style="font-weight:
            bold;"><br>
            void set(double val, int precision)</span> sets the content
          of the DvString to the text equivalent of val, but limits the
          number of places after the decimal point to <b>precision</b>.
          Uses scientific notation for <b>value</b> below 0.1 or above
          1000.</span><br style="font-family:
          Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-weight: bold;">void append(double d, const char
            * spacer)</span> appends the text spacer followed by value
          of double d as a string</span><span style="font-family:
          Helvetica,Arial,sans-serif;"></span> <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-weight: bold;"><br>
            void append(double d, const char * spacer, int precision)</span>
          appends the text spacer followed by value of double d as a
          string</span><span style="font-family:
          Helvetica,Arial,sans-serif;"></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-family:
            Helvetica,Arial,sans-serif;">, but limits the number of
            places after the decimal point to <b>precision</b>. Uses
            scientific notation for <b>value</b> below 0.1 or above
            1000.<br>
          </span><span style="font-weight: bold;">void append(int i</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, const char * spacer</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span> appends the </span><span style="font-family: Helvetica,Arial,sans-serif;">text spacer
          followed by </span><span style="font-family:
          Helvetica,Arial,sans-serif;">value of int i as a string</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          <span style="font-weight: bold;">void append(DvTime t</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, const char * spacer</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span> appends the </span><span style="font-family: Helvetica,Arial,sans-serif;">text spacer
          followed by </span><span style="font-family:
          Helvetica,Arial,sans-serif;">value of DvTime t as a string</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          <span style="font-weight: bold;">void append(DvEvent e</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, const char * spacer</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span> appends the </span><span style="font-family: Helvetica,Arial,sans-serif;">text spacer
          followed by </span><span style="font-family:
          Helvetica,Arial,sans-serif;">value of DvEvent e as a string</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          The default spacer is an empty string. Appending to an empty
          string can be used in place of an assignment.<br>
          Note that the method<span style="font-weight: bold;"> s =
            t_var-&gt;getISOstring()</span> can be used to create a
          DvString from a DvTime or DvEvent.<br>
          The operator <span style="font-weight: bold;">+=</span> is
          equivalent to <span style="font-weight: bold;">append</span>
          with default empty spacer, and is overloaded to work for
          double, int, DvTime, DvEvent, DvString, string and const
          char*.<br>
        </span><big style="font-family: Helvetica,Arial,sans-serif;"><small>
            <span style="font-weight: bold;">DvObject_var
              changeUnitsTo(DvString SIC, DvString Units</span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;"></span></small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-weight: bold;">)</span> returns a DvObject
            pointer containing a copy of <span style="font-weight:
              bold;">this</span> converted to the</small></big><span style="font-family: Helvetica,Arial,sans-serif;"> units
          specified in the SI_conversion string SIC. The Units argument
          is used for the Units attribute in the returned object and are
          free form text. To convert to km/s one<br>
          could specify changeUnitsTo("1.0e3&gt;m s^-1", "km/s"). The
          conversions to DvString are done automatically at run time.<br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;
          color: rgb(153, 0, 0); font-weight: bold;">Case sensitivity</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvString toUpper()</span> returns
          the same string converted to upper case. Characters with no
          upper case remain unchanged</span><br style="font-family:
          Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;">The <span style="font-weight: bold;">operator ==</span> returns true
          if the strings are the same when both converted to upper case
          (this is thus a case insensitive method of comparing strings
          which is useful for attributes). It tages either a DvString or
          const char * as target.<br style="font-family:
            Helvetica,Arial,sans-serif;">
          <span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-weight: bold;">bool contains(DvString &amp;vs)</span><br style="font-weight: bold;">
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool contains(const char *cs)</span>
          both return true if this string contains vs or cs
          respectively. Like the <span style="font-weight: bold;">operator








            ==</span> compared strings are converted to upper case
          before comparison.<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool containsCS(DvString &amp;vs)</span><br style="font-weight: bold;">
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool containsCS(const char *cs) </span>are








          the equivalent case sensitive methods.</span><br>
        <br>
        <br>
        <div style="text-align: center;"><span style="font-family:
            Helvetica,Arial,sans-serif; font-weight: bold;"><a name="Time"></a>DvTime Class</span><br style="font-family: Helvetica,Arial,sans-serif;">
        </div>
        <br style="font-family: Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;">The
          DvTime class stores date and time as an integer <span style="font-weight: bold;">(base_day)</span>, day in </span><span style="font-family: Helvetica,Arial,sans-serif;">Modified
          Julian Date</span><span style="font-family:
          Helvetica,Arial,sans-serif;">, and a double <span style="font-weight: bold;">(time_sec)</span> counting
          seconds since the start of <span style="font-weight: bold;">base_day</span>.
          See DvTime.h for more details of Modified Julian Date (MJD).
          For reference January 01, 2000 has <span style="font-weight:
            bold;">base_day</span> 51544, and is the default date.<br>
          <br>
          The accuracy to which time can be given are limited only by
          the limits imposed by the double used to store it. For
          reasonable dates this should allow better than nanosecond
          accuracy. The number of digits shown after the decimal point
          in the seconds field can be controlled for text format output.<br>
          <br>
          Arithmetic is always done modulo hours, minutes and seconds,
          so, for example, setting a time with 1hr 62s will safely be
          treated as 2hr 2s.<br>
          <br>
          The constructors are:<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime(double sec=0.0, int
            day=MJD2000)</span> constructs a time from any date and
          seconds offset, (default 2000-01-01 00:00:00.0000).</span><span style="font-family: Helvetica,Arial,sans-serif;">&nbsp; <span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime(const char* iso_time )</span>
          constructs a time from a date string in ISO format.</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime(const








            string&amp; iso_time )</span> constructs a time from a date
          string in ISO format.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime(int








            year, int month=1, int day=1, int hour=0, int min=0, double
            sec=0.0 )</span> constructs a time from date_time elements.</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            DvTime(const DvTime&amp; ttime )</span> copy constructor.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;
          color: rgb(153, 0, 0); font-weight: bold;">Setting DvTime </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void








            setFromUT(int year, int month, int day, int hour, int min,
            double sec)</span> sets the<span style="font-family:
            Helvetica,Arial,sans-serif;"> time from individual elements
            in UT.</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            void setFromDOY(int year, int dofy, int hour, int min,
            double sec)</span> sets the<span style="font-family:
            Helvetica,Arial,sans-serif;"> time from individual elements
            in UT using day of year.</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            void setFromBCE(</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">int








            yearBCE, int month, int day, int hour, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">int min, double sec)</span> sets
          the<span style="font-family: Helvetica,Arial,sans-serif;">
            time from individual elements in UT for year<br>
            before current epoch (formerly BC).</span></span><br style="font-family: Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void setFromMJD(double
            ModifiedJulianDate)</span> set from Modified Julian Date
          (includes fraction of day)</span><span style="font-family:
          Helvetica,Arial,sans-serif;">.<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void setFromCDFepoch(double
            cdf_epoch)</span> set from CDF epoch value</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">.<br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void








            setFromCDFepoch16(double *cdf_epoch16)</span> set from a
          pair of CDF epoch16 value</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">s.<br>
            <span style="font-weight: bold;">void setFromJD</span>(double








            JulianDate)</span> set from Julian Date.</span><br style="font-family: Helvetica,Arial,sans-serif;">
        <big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-weight: bold;">void setFromEpoch2000(double
              sec)</span> set from seconds after Jan 01, 2000.</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-weight: bold;"><br>
            </span></small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small><span style="font-weight:
              bold;">void setFromISOstring(const char * ISOstring)</span>
            set from ISO format string.</small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><br>
          </small></big><big style="font-family:
          Helvetica,Arial,sans-serif;"><small><span style="font-weight:
              bold;">void setFromISOstring(string ISOstring)</span> set
            from ISO format string.</small></big><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime&amp; setToday()</span>
          sets the date to today's date at the start of the day.</span><br>
        <big style="font-family: Helvetica,Arial,sans-serif;"><small> </small></big><big style="font-family: Helvetica,Arial,sans-serif;"><small><br>
          </small></big><span style="font-family:
          Helvetica,Arial,sans-serif; color: rgb(153, 0, 0);
          font-weight: bold;">Accessing DvTime </span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">int breakDownMJD(int *year, int
            *month, int *day, int *hour, int *min, double *sec)</span>
          breaks a DvTime down into the date_time elements.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double getMJD()</span> returns
          MJD as a double (includes fraction of day).</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double getJD()</span> returns JD
          as a double (includes fraction of day).</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double getDiffDays(const DvTime
            &amp;arg)</span> returns the difference in days between this
          DvTime and arg (this - arg).</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            double getDiffSecs(const DvTime &amp;arg)</span> returns the
          difference in seconds between this DvTime and arg (this -
          arg).</span><br>
        <big style="font-family: Helvetica,Arial,sans-serif;"> </big><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double getCDFepoch()</span>
          returns the time as a double CDF epoch value</span>.<big style="font-family: Helvetica,Arial,sans-serif;"> </big><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            void getCDFepoch16(double *epoch16)</span> returns the time
          as a pair of doubles as used in CDF epoch16</span>.<br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double getEpoch2000()</span>
          returns the time as a double seconds since Epoch2000 (Jan 01,
          2000)</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            double getEpoch1970()</span> returns the time as a double
          seconds since Epoch1970 (Jan 01, 1970)</span><br style="font-family: Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">std::string getISOstring(int
            delim)</span> returns an ISO format standard string, if
          delim=0 (default) a space separates the date and time, if
          delim=1 a capital T separates them, if delim=2 a trailing Z is
          also appended.</span><br style="font-family:
          Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">const char * getDayOfWeek()</span>
          returns the three letter abbreviation for the day of the week
          for this date.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">const








            char * getLongDayOfWeek()</span> returns the unabbreviated
          day of the week for this date.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">const








            char * getMonth(int m)</span> returns the abbreviated month
          for m.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            const char * getLongMonth(int m)</span> returns the
          unabbreviated month for m.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool getYandD(int *year, int*
            day)</span> finds the year and day of year and returns true
          if it is a leap year.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">size_t strfMJD(char * buf, size_t
            len, const char *format)</span> Formats a text string
          according to the format string. Uses the same syntax as
          strftime() but does not use current locale. The null
          terminator must be included in len which is the size of the
          buffer. Returns the length of the formatted string.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime normalized() const</span>
          returns the same date_time but with the seconds field being
          less than a day, and base_day modified accordingly.<br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;
          color: rgb(153, 0, 0); font-weight: bold;">Setting Options </span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void setSecResolution(int
            resolution)</span> sets the<span style="font-family:
            Helvetica,Arial,sans-serif;"> number of decimal places to be
            shown in seconds field </span>in string format<span style="font-weight: bold;">.</span></span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void setGregorianStartMJD(double
            GregorianMJD)</span> sets the<span style="font-family:
            Helvetica,Arial,sans-serif;"> start date used for the
            Gregorian calendar</span>. This was not uniform between
          cultures (or software).</span><span style="font-family:
          Helvetica,Arial,sans-serif;"> Default uses the Gregorian
          calendar after 4 Oct 1582 (Julian) i.e. from 15 Oct 1582
          Gregorian.<br>
          Note unix libraries use Gregorian only from 14 Sept 1752.<span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span>&nbsp;&nbsp;&nbsp;








        <br>
        <span style="font-family: Helvetica,Arial,sans-serif; color:
          rgb(153, 0, 0); font-weight: bold;">Operators </span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime&amp; operator=( const
            DvTime&amp; ttime )</span></span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime&amp; operator=(&nbsp;
            const double dtime )</span><span style="font-weight: bold;"></span>
          where dtime is a double time since Epoch2000.</span> <br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime&amp; operator=(&nbsp;
            const string&amp; isotime )</span><span style="font-weight:
            bold;"></span> where isotime is a string date_time in ISO
          format.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> double operator=(&nbsp; const
            DvTime&amp; ttime )</span><span style="font-weight: bold;"></span>
          returns the time in seconds since Epoch2000.<br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime&amp; operator*=(&nbsp;
            const double factor )</span><span style="font-weight: bold;"></span>
          provided only for intermediate steps in forming averages etc,
          may not yield a valid time.</span> <br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime&amp; operator/=(&nbsp;
            const double factor )</span><span style="font-weight: bold;"></span>
          provided only for intermediate steps in forming averages etc,
          may not yield a valid time.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"></span> <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            DvTime&amp; operator+=(&nbsp; const double factor )</span><span style="font-weight: bold;"></span> provided only for
          intermediate steps in forming averages etc, may not yield a
          valid time.</span> <br>
        <span style="font-family: Helvetica,Arial,sans-serif;"></span> <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime&amp; operator-=(&nbsp;
            const double factor )</span><span style="font-weight: bold;"></span>
          provided only for intermediate steps in forming averages etc,
          may not yield a valid time.</span> <br>
        <span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime&amp; operator+=(&nbsp;
            const double sec )</span><span style="font-weight: bold;"></span>
          adds seconds <span style="font-weight: bold;">sec</span>.</span>
        <span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            DvTime&amp; operator-=(&nbsp; const double sec )</span><span style="font-weight: bold;"></span> subtracts seconds <span style="font-weight: bold;">sec</span>.</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            <br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime








            operator+(&nbsp; const double sec )</span><span style="font-weight: bold;"></span> returns the time plus
          seconds <span style="font-weight: bold;">sec</span>.</span> <span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            DvTime operator-(&nbsp; const double sec )</span><span style="font-weight: bold;"></span> returns the time minus
          seconds <span style="font-weight: bold;">sec</span>.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double operator-(&nbsp; const
            DvTime&amp; ttime )</span><span style="font-weight: bold;"></span>
          returns the difference between times in seconds.</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> <br>
          </span></span><br>
        &nbsp;&nbsp;&nbsp; <br>
        <span style="font-family: Helvetica,Arial,sans-serif; color:
          rgb(153, 0, 0); font-weight: bold;">Logical Operators </span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool operator==( const
            DvTime&amp; ttime )</span> returns true if times are the
          same to an accuracy of .1 nanoseconds.</span> <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            bool operator!=( const DvTime&amp; ttime )</span> returns
          true if times are not the same to an accuracy of .1
          nanoseconds.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            bool operator&lt;( const DvTime&amp; ttime )</span> returns
          true if this is before ttime.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            bool operator&lt;=( const DvTime&amp; ttime )</span> returns
          true if this is before or equal to ttime</span><span style="font-family: Helvetica,Arial,sans-serif;"> to an
          accuracy of .1 nanoseconds</span><span style="font-family:
          Helvetica,Arial,sans-serif;">.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool








            operator&gt;( const DvTime&amp; ttime )</span> returns true
          if this is after ttime.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            bool operator&gt;( const DvTime&amp; ttime )</span> </span><span style="font-family: Helvetica,Arial,sans-serif;">returns true
          if this is after or equal to ttime</span><span style="font-family: Helvetica,Arial,sans-serif;"> to an
          accuracy of .1 nanoseconds</span><span style="font-family:
          Helvetica,Arial,sans-serif;">.</span><br>
        &nbsp;&nbsp;&nbsp; <br>
        <span style="font-family: Helvetica,Arial,sans-serif; color:
          rgb(153, 0, 0); font-weight: bold;">Utilities </span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">int getSecResolution()</span>
          returns an estimate of the number of characters after the
          seconds decimal place. If the object is neither time or event
          then zero is returned.</span><br>
        <br>
        <br>
        <div style="text-align: center;"><span style="font-family:
            Helvetica,Arial,sans-serif; font-weight: bold;"><a name="Event"></a>DvEvent
            Class</span><br style="font-family:
            Helvetica,Arial,sans-serif;">
        </div>
        <br style="font-family: Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;">The
          DvEvent class stores time intervals as two DvTime values, _t1
          and _t2</span><span style="font-family:
          Helvetica,Arial,sans-serif;">. In the following, tests to
          "better than nanosecond accuracy" use fuzzy equality tests
          within 0.1 nanoseconds.<br>
          <br>
          <br>
          The constructors are:<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvEvent()</span> constructs an
          interval from DvTime() to DvTime+1.0 seconds</span><span style="font-family: Helvetica,Arial,sans-serif;">.</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvEvent(const DvEvent&amp; event)</span>
          copy constructor</span><span style="font-family:
          Helvetica,Arial,sans-serif;">.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvEvent(string








            &amp;ISOstring)</span> constructs from an ISO standard time
          interval string</span><span style="font-family:
          Helvetica,Arial,sans-serif;"> (two ISO date_time strings
          separated by '/')</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">.<br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvEvent(const








            DvTime&amp; st, const DvTime&amp; ed, Sense option)</span>
          construct from two DvTime objects. </span><span style="font-family: Helvetica,Arial,sans-serif;">If <span style="font-weight: bold;">option</span> is </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">NO_TIME_SENSE</span> (default),
          then <span style="font-weight: bold;">_t1</span> and <span style="font-weight: bold;">_t1</span> are set from <span style="font-weight: bold;">st</span> and <span style="font-weight: bold;">ed</span> respectively. </span><span style="font-family: Helvetica,Arial,sans-serif;">If <span style="font-weight: bold;">option</span> is <span style="font-weight: bold;">TIME_SENSE_NEGATIVE</span> or <span style="font-weight: bold;">TIME_SENSE_POSITIVE</span> the
          two times are ordered appropriately.</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;
          color: rgb(153, 0, 0); font-weight: bold;">Methods</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime








            start()</span> returns _t1<span style="font-weight: bold;">.</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime








            end()</span> returns _t2<span style="font-weight: bold;">.</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime








            start_abs()</span> returns earlier of _t1, _t2<span style="font-weight: bold;">.</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvTime








            end_abs()</span> returns later of _t1, _t2.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> set_start(const DvTime&amp; st)</span><span style="font-family: Helvetica,Arial,sans-serif;"> set</span>s
          the value of <span style="font-weight: bold;">_t1</span> to <span style="font-weight: bold;">st</span>.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> set_end(const DvTime&amp; ed)</span><span style="font-family: Helvetica,Arial,sans-serif;"> set</span>s
          the value of <span style="font-weight: bold;">_t2</span> to <span style="font-weight: bold;">ed</span>.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void set(const DvTime&amp; st,
            const DvTime&amp; ed, Sense option)</span> sets the event
          from the two DvTime objects. </span><span style="font-family:
          Helvetica,Arial,sans-serif;">If <span style="font-weight:
            bold;">option</span> is </span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">NO_TIME_SENSE</span>
          (default), then <span style="font-weight: bold;">_t1</span>
          and <span style="font-weight: bold;">_t1</span> are set from
          <span style="font-weight: bold;">st</span> and <span style="font-weight: bold;">ed</span> respectively. </span><span style="font-family: Helvetica,Arial,sans-serif;">If <span style="font-weight: bold;">option</span> is <span style="font-weight: bold;">TIME_SENSE_NEGATIVE</span> or <span style="font-weight: bold;">TIME_SENSE_POSITIVE</span> the
          two times are ordered appropriately.</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void setFromISOstring(const char*
            ISOstring)</span> sets the event from an</span><span style="font-family: Helvetica,Arial,sans-serif;"> ISO standard
          event string.<span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void setFromISOstring(string
            &amp; ISOstring)</span> sets the event from an</span><span style="font-family: Helvetica,Arial,sans-serif;"> ISO standard
          event string.<br>
          <br>
          <span style="font-weight: bold;"> </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">std::string&nbsp;</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> getISOstring(int delim)</span>
          returns event is ISO standard string format. If delim=0
          (default) date and time elements are space separated, if
          delim=1 then they are separated with character 'T' and if
          delim=2 the date_time strings are also terminated with the
          character 'Z'.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            Sense</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            get_sense()</span> returns one of </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">NO_TIME_SENSE (</span></span><span style="font-family: Helvetica,Arial,sans-serif;">if _t1 == _t2
          to better than nanosecond accuracy)</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">, </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">TIME_SENSE_NEGATIVE </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> (</span></span><span style="font-family: Helvetica,Arial,sans-serif;">if _t1 &gt;
          _t2 )</span><span style="font-family:
          Helvetica,Arial,sans-serif;"> or</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> TIME_SENSE_POSITIVE</span></span><span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">(</span></span><span style="font-family: Helvetica,Arial,sans-serif;">if _t1 &lt;
          _t2 )</span><span style="font-family:
          Helvetica,Arial,sans-serif;"></span><span style="font-family:
          Helvetica,Arial,sans-serif;">.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
            void</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            force_sense(Sense option)</span> sets the ordering of _t1
          and _t2 according to the value of option (default is </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">TIME_SENSE_POSITIVE</span></span><span style="font-family: Helvetica,Arial,sans-serif;">).</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">void</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> reverse()</span> swaps the
          values <span style="font-weight: bold;">_t1</span> and <span style="font-weight: bold;">_t2</span>.<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double duration()</span> returns
          <span style="font-weight: bold;">_t2</span> - <span style="font-weight: bold;">_t1</span> in seconds.<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double duration_abs()</span>
          returns the absolute value of <span style="font-weight:
            bold;">_t2</span> - <span style="font-weight: bold;">_t1</span>
          in seconds.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">std::string iso_srep()</span>
          returns the interval as two ISO&nbsp; date_time strings
          separated by " - " for display purposes.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          <span style="font-weight: bold;">DvTime max(DvTime &amp;t1,
            DvTime &amp;t2)</span> returns the later of <span style="font-weight: bold;">_t1</span> and <span style="font-weight: bold;">_t2</span>.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          <span style="font-weight: bold;">DvTime min(DvTime &amp;t1,
            DvTime &amp;t2)</span> returns the earlier of <span style="font-weight: bold;">_t1</span> and <span style="font-weight: bold;">_t2</span>.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          <br>
          <span style="font-weight: bold;">DvEvent int_intersect(const
            DvEvent&amp; ti)</span> returns the intersect of <span style="font-weight: bold;">this</span> event with event <span style="font-weight: bold;">ti</span>.<br>
          <span style="font-weight: bold;">DvEvent int_union(const
            DvEvent&amp; ti)</span> </span><span style="font-family:
          Helvetica,Arial,sans-serif;">returns the union of <span style="font-weight: bold;">this</span> event with event <span style="font-weight: bold;">ti</span>.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          <span style="font-weight: bold;">bool contains( const
            DvTime&amp; t )</span> returns true if the time <span style="font-weight: bold;">t</span> is inside <span style="font-weight: bold;">this</span> event interval.<br>
          <span style="font-weight: bold;">bool intersects( const
            DvEvent&amp; tivl ) </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;">returns true if the </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span> event <span style="font-weight: bold;">tivl</span> overlaps <span style="font-weight: bold;">this</span> event.<br>
          <span style="font-weight: bold;">bool empty()&nbsp;</span>
          returns true if the start and end times are the same to better
          than nanosecond accuracy.<br>
          <br>
        </span>&nbsp;&nbsp;&nbsp; <br>
        <span style="font-family: Helvetica,Arial,sans-serif; color:
          rgb(153, 0, 0); font-weight: bold;">Operators </span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvEvent&amp; operator=(&nbsp;
            const DvEvent event )</span><span style="font-weight: bold;"></span>
          copy operator.</span> <br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvEvent&amp; operator+=(&nbsp;
            double offset )</span><span style="font-weight: bold;"></span>
          adds the value <span style="font-weight: bold;">offset</span>
          (in seconds) to both start and end times.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvEvent&amp; operator-=(&nbsp;
            double offset )</span><span style="font-weight: bold;"></span>
          subtracts the value <span style="font-weight: bold;">offset</span>
          (in seconds) from both start and end times.</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span> <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double operator*(&nbsp; const
            double multiplier )</span><span style="font-weight: bold;"></span>
          returns the <span style="font-weight: bold;">duration()</span>
          of the interval multiplied by <span style="font-weight:
            bold;">multiplier</span>.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><br>
          <span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> operator==(&nbsp; const
            DvEvent&amp; event )</span><span style="font-weight: bold;"></span>
          returns true if the start and end times of <span style="font-weight: bold;">this</span> and <span style="font-weight: bold;">event</span> are the same to
          better than nanosecond accuracy.<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> operator!=(&nbsp; const
            DvEvent&amp; event )</span><span style="font-weight: bold;"></span>
          returns true if the equality operator above returns false.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"> </span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"> operator&gt;(&nbsp; const
            DvEvent&amp; event )</span><span style="font-weight: bold;"></span>
          returns true if the <span style="font-weight: bold;">start()</span>
          of <span style="font-weight: bold;">this</span> is after the
          <span style="font-weight: bold;">start()</span> of <span style="font-weight: bold;">event</span>, of if the starts
          are equal and the<span style="font-weight: bold;"> end()</span>
          of <span style="font-weight: bold;">this</span> is after the
          <span style="font-weight: bold;">end()</span> of <span style="font-weight: bold;">event</span>. Otherwise returns
          false.</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          <br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><big style="font-family: Helvetica,Arial,sans-serif;"><small><br>
          </small></big><br>
        <div style="text-align: center;"><span style="font-family:
            Helvetica,Arial,sans-serif; font-weight: bold;"><a name="MatEig"></a>DvMatrixEig
            Class</span><br style="font-family:
            Helvetica,Arial,sans-serif;">
        </div>
        <span style="font-family: Helvetica,Arial,sans-serif;"> <br>
          The constructor for the </span><span style="font-family:
          Helvetica,Arial,sans-serif;"> <span style="font-weight:
            bold;"> DvMatrixEig</span> class</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;"> DvMatrixEig</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">(DvObject_var &amp;m)</span> </span><span style="font-family: Helvetica,Arial,sans-serif;">evaluates the
          eigenvalues and eigenvectors for the matrix <span style="font-weight: bold;">m</span>, and holds them
          internally. The matrix must have rank 2, and the two
          dimensions must be equal (2D square matrix of dimension </span><span style="font-family: Helvetica,Arial,sans-serif;"> <span style="font-weight: bold;">n</span>x<span style="font-weight: bold;">n</span></span><span style="font-family: Helvetica,Arial,sans-serif;">) otherwise
          both eigenvectors and eigenvalues are empty objects.</span><span style="font-family: Helvetica,Arial,sans-serif;"></span> <br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;
          color: rgb(153, 0, 0); font-weight: bold;">Methods</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
              Helvetica,Arial,sans-serif;"><span style="font-weight:
                bold;"><span style="font-family:
                  Helvetica,Arial,sans-serif;"><span style="font-weight:
                    bold;">_var </span></span></span></span>eigenvalues()</span>
          returns the eigenvalues as a 1D array of <span style="font-weight: bold;">n</span> elements<span style="font-weight: bold;">.</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
              Helvetica,Arial,sans-serif;"><span style="font-weight:
                bold;"><span style="font-family:
                  Helvetica,Arial,sans-serif;"><span style="font-weight:
                    bold;">_var </span></span></span></span>eigenvectors()</span>
          returns the eigenvectors as a 2D array of <span style="font-weight: bold;">n</span>x<span style="font-weight: bold;">n</span> elements, with vectors
          stored as rows. Note they are calculated as columns using
          d_eigen, and then transposed.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            <br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><br>
        <br>
        <br>
        <div style="text-align: center;"><span style="font-family:
            Helvetica,Arial,sans-serif; font-weight: bold;"><a name="MinVar"></a>DvMinVariance








            Class</span><br style="font-family:
            Helvetica,Arial,sans-serif;">
        </div>
        <span style="font-family: Helvetica,Arial,sans-serif;"> <br>
          This class finds the minimum and maximum variance directions
          of a vector sequence.<br>
          &nbsp;</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"> The
          constructor for the</span><span style="font-family:
          Helvetica,Arial,sans-serif; font-weight: bold;">DvMinVariance</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"> class</span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;
          font-weight: bold;">DvMinVariance</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">(DvObject_var &amp;vs,
            DvObject_var &amp;constraint, const int </span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">method</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">)</span> </span><span style="font-family: Helvetica,Arial,sans-serif;">determines
          the minimum for the vector sequence <span style="font-weight:
            bold;">vs</span> subject to an optional constraint <span style="font-weight: bold;">constraint</span>, and using the
          method specified by the integer <span style="font-weight:
            bold;">method</span>. If constraint is an empty object it is
          ignored. For constraint non-empty, see ISSI blue book and
          notes in the code.<br>
          <span style="font-weight: bold;">&nbsp;<br>
          </span>The method may be one of:<br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">method







          = 1 uses the classic covariance matrix and is the default</span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">method







          = 2 uses the Weimer type covariance matrix </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;">method







          = 3 uses the Siscoe type covariance matrix </span><span style="font-family: Helvetica,Arial,sans-serif;"><br>
          method = 4 should not be used, and is retained only for
          completeness, it uses the extreme Weimer type covariance
          matrix (N -&gt; infinity)</span><br>
        <br>
        <br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><br>
        </span><span style="font-family: Helvetica,Arial,sans-serif;
          color: rgb(153, 0, 0); font-weight: bold;">Methods</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject_var


            eigenvalues()</span> returns the eigenvalues as a sequence
          of 1D array of <span style="font-weight: bold;">n</span>
          elements<span style="font-weight: bold;">.</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
              Helvetica,Arial,sans-serif;"><span style="font-weight:
                bold;">_var </span></span>eigenvectors()</span> returns
          the eigenvectors (Rotation matrix sequence).</span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
              Helvetica,Arial,sans-serif;"><span style="font-weight:
                bold;"><span style="font-family:
                  Helvetica,Arial,sans-serif;"><span style="font-weight:
                    bold;">_var </span></span></span></span>projection()</span>
          returns the projection (<span style="font-weight: bold;">n</span>x<span style="font-weight: bold;">n</span> matrix sequence), see
          ISSI book.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
              Helvetica,Arial,sans-serif;"><span style="font-weight:
                bold;"><span style="font-family:
                  Helvetica,Arial,sans-serif;"><span style="font-weight:
                    bold;">_var </span></span></span></span>covariance()</span>
          returns the covariance (<span style="font-weight: bold;">n</span>x<span style="font-weight: bold;">n</span> matrix sequence).</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">DvObject</span></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><span style="font-family:
              Helvetica,Arial,sans-serif;"><span style="font-weight:
                bold;"><span style="font-family:
                  Helvetica,Arial,sans-serif;"><span style="font-weight:
                    bold;">_var </span></span></span></span>eigenquality()</span>
          returns the eigenvalue quality (</span><span style="font-family: Helvetica,Arial,sans-serif;">as a sequence
          of 1D array of <span style="font-weight: bold;">n</span>
          elements</span><span style="font-family:
          Helvetica,Arial,sans-serif;">).</span><span style="font-family: Helvetica,Arial,sans-serif;"></span><span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"><br>
          </span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            double</span></span><span style="font-family:
          Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">
            orthogonality_quality()</span> returns the orthogonality
          quality</span><span style="font-family:
          Helvetica,Arial,sans-serif;">.</span><span style="font-family:
          Helvetica,Arial,sans-serif;"><br>
        </span><br>
        <span style="font-family: Helvetica,Arial,sans-serif;"> <br>
        </span><br>
        <div style="text-align: center;"><span style="font-family:
            Helvetica,Arial,sans-serif; font-weight: bold;"><a name="Util"></a>Accessible
            Internal Utilities </span><br style="font-family:
            Helvetica,Arial,sans-serif;">
        </div>
        <span style="font-family: Helvetica,Arial,sans-serif;"> <br>
          There are a few useful general functions used inside DVOS that
          can be accessed directly.<br>
          <span style="font-family: Helvetica,Arial,sans-serif;">&nbsp;
          </span></span><br style="font-family:
          Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">valarray &lt;double&gt;
            atan_yx(valarray &lt;double&gt; &amp;y, valarray
            &lt;double&gt; &amp;x)</span> provides the function
          atan2(y,x) on a valarray, with the result in (0, 2pi).</span><br style="font-family: Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">double atan_yx( double y,&nbsp;
            double x)</span> provides the function atan2() with result
          in (0, 2pi).</span><br style="font-family:
          Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;">bool isFill(double val, double
            fill)</span> returns <span style="font-weight: bold;">true</span>
          if the value <span style="font-weight: bold;">val</span> is
          not a number or satisfies a fuzzy equality with <span style="font-weight: bold;">fill</span>.</span><br style="font-family: Helvetica,Arial,sans-serif;">
        <span style="font-family: Helvetica,Arial,sans-serif;
          font-weight: bold;">bool notFill(double val, double fill)</span><span style="font-family: Helvetica,Arial,sans-serif;"> returns <span style="font-weight: bold;">false</span> if the value <span style="font-weight: bold;">val</span> is not a number or
          satisfies a fuzzy equality with <span style="font-weight:
            bold;">fill</span>.</span><br>
        <br>
        <br>
        <span style="font-family: Helvetica,Arial,sans-serif;"><span style="font-weight: bold;"></span></span></div>
    </div>
  

</body></html>